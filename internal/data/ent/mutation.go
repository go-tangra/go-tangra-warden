// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/go-tangra/go-tangra-warden/internal/data/ent/auditlog"
	"github.com/go-tangra/go-tangra-warden/internal/data/ent/folder"
	"github.com/go-tangra/go-tangra-warden/internal/data/ent/permission"
	"github.com/go-tangra/go-tangra-warden/internal/data/ent/predicate"
	"github.com/go-tangra/go-tangra-warden/internal/data/ent/secret"
	"github.com/go-tangra/go-tangra-warden/internal/data/ent/secretversion"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAuditLog      = "AuditLog"
	TypeFolder        = "Folder"
	TypePermission    = "Permission"
	TypeSecret        = "Secret"
	TypeSecretVersion = "SecretVersion"
)

// AuditLogMutation represents an operation that mutates the AuditLog nodes in the graph.
type AuditLogMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uint32
	create_time          *time.Time
	update_time          *time.Time
	delete_time          *time.Time
	tenant_id            *uint32
	addtenant_id         *int32
	audit_id             *string
	request_id           *string
	operation            *string
	service_name         *string
	client_id            *string
	client_common_name   *string
	client_organization  *string
	client_serial_number *string
	is_authenticated     *bool
	success              *bool
	error_code           *int32
	adderror_code        *int32
	error_message        *string
	latency_ms           *int64
	addlatency_ms        *int64
	peer_address         *string
	geo_location         *map[string]string
	log_hash             *string
	signature            *[]byte
	metadata             *map[string]string
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*AuditLog, error)
	predicates           []predicate.AuditLog
}

var _ ent.Mutation = (*AuditLogMutation)(nil)

// auditlogOption allows management of the mutation configuration using functional options.
type auditlogOption func(*AuditLogMutation)

// newAuditLogMutation creates new mutation for the AuditLog entity.
func newAuditLogMutation(c config, op Op, opts ...auditlogOption) *AuditLogMutation {
	m := &AuditLogMutation{
		config:        c,
		op:            op,
		typ:           TypeAuditLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuditLogID sets the ID field of the mutation.
func withAuditLogID(id uint32) auditlogOption {
	return func(m *AuditLogMutation) {
		var (
			err   error
			once  sync.Once
			value *AuditLog
		)
		m.oldValue = func(ctx context.Context) (*AuditLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuditLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuditLog sets the old AuditLog of the mutation.
func withAuditLog(node *AuditLog) auditlogOption {
	return func(m *AuditLogMutation) {
		m.oldValue = func(context.Context) (*AuditLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuditLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuditLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AuditLog entities.
func (m *AuditLogMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuditLogMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuditLogMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuditLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *AuditLogMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AuditLogMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *AuditLogMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[auditlog.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *AuditLogMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AuditLogMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, auditlog.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *AuditLogMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AuditLogMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *AuditLogMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[auditlog.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *AuditLogMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AuditLogMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, auditlog.FieldUpdateTime)
}

// SetDeleteTime sets the "delete_time" field.
func (m *AuditLogMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *AuditLogMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *AuditLogMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[auditlog.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *AuditLogMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *AuditLogMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, auditlog.FieldDeleteTime)
}

// SetTenantID sets the "tenant_id" field.
func (m *AuditLogMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *AuditLogMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *AuditLogMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *AuditLogMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *AuditLogMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[auditlog.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *AuditLogMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *AuditLogMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, auditlog.FieldTenantID)
}

// SetAuditID sets the "audit_id" field.
func (m *AuditLogMutation) SetAuditID(s string) {
	m.audit_id = &s
}

// AuditID returns the value of the "audit_id" field in the mutation.
func (m *AuditLogMutation) AuditID() (r string, exists bool) {
	v := m.audit_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAuditID returns the old "audit_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldAuditID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuditID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuditID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuditID: %w", err)
	}
	return oldValue.AuditID, nil
}

// ResetAuditID resets all changes to the "audit_id" field.
func (m *AuditLogMutation) ResetAuditID() {
	m.audit_id = nil
}

// SetRequestID sets the "request_id" field.
func (m *AuditLogMutation) SetRequestID(s string) {
	m.request_id = &s
}

// RequestID returns the value of the "request_id" field in the mutation.
func (m *AuditLogMutation) RequestID() (r string, exists bool) {
	v := m.request_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestID returns the old "request_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldRequestID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestID: %w", err)
	}
	return oldValue.RequestID, nil
}

// ClearRequestID clears the value of the "request_id" field.
func (m *AuditLogMutation) ClearRequestID() {
	m.request_id = nil
	m.clearedFields[auditlog.FieldRequestID] = struct{}{}
}

// RequestIDCleared returns if the "request_id" field was cleared in this mutation.
func (m *AuditLogMutation) RequestIDCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldRequestID]
	return ok
}

// ResetRequestID resets all changes to the "request_id" field.
func (m *AuditLogMutation) ResetRequestID() {
	m.request_id = nil
	delete(m.clearedFields, auditlog.FieldRequestID)
}

// SetOperation sets the "operation" field.
func (m *AuditLogMutation) SetOperation(s string) {
	m.operation = &s
}

// Operation returns the value of the "operation" field in the mutation.
func (m *AuditLogMutation) Operation() (r string, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldOperation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *AuditLogMutation) ResetOperation() {
	m.operation = nil
}

// SetServiceName sets the "service_name" field.
func (m *AuditLogMutation) SetServiceName(s string) {
	m.service_name = &s
}

// ServiceName returns the value of the "service_name" field in the mutation.
func (m *AuditLogMutation) ServiceName() (r string, exists bool) {
	v := m.service_name
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceName returns the old "service_name" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldServiceName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServiceName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServiceName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceName: %w", err)
	}
	return oldValue.ServiceName, nil
}

// ResetServiceName resets all changes to the "service_name" field.
func (m *AuditLogMutation) ResetServiceName() {
	m.service_name = nil
}

// SetClientID sets the "client_id" field.
func (m *AuditLogMutation) SetClientID(s string) {
	m.client_id = &s
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *AuditLogMutation) ClientID() (r string, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ClearClientID clears the value of the "client_id" field.
func (m *AuditLogMutation) ClearClientID() {
	m.client_id = nil
	m.clearedFields[auditlog.FieldClientID] = struct{}{}
}

// ClientIDCleared returns if the "client_id" field was cleared in this mutation.
func (m *AuditLogMutation) ClientIDCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldClientID]
	return ok
}

// ResetClientID resets all changes to the "client_id" field.
func (m *AuditLogMutation) ResetClientID() {
	m.client_id = nil
	delete(m.clearedFields, auditlog.FieldClientID)
}

// SetClientCommonName sets the "client_common_name" field.
func (m *AuditLogMutation) SetClientCommonName(s string) {
	m.client_common_name = &s
}

// ClientCommonName returns the value of the "client_common_name" field in the mutation.
func (m *AuditLogMutation) ClientCommonName() (r string, exists bool) {
	v := m.client_common_name
	if v == nil {
		return
	}
	return *v, true
}

// OldClientCommonName returns the old "client_common_name" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldClientCommonName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientCommonName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientCommonName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientCommonName: %w", err)
	}
	return oldValue.ClientCommonName, nil
}

// ClearClientCommonName clears the value of the "client_common_name" field.
func (m *AuditLogMutation) ClearClientCommonName() {
	m.client_common_name = nil
	m.clearedFields[auditlog.FieldClientCommonName] = struct{}{}
}

// ClientCommonNameCleared returns if the "client_common_name" field was cleared in this mutation.
func (m *AuditLogMutation) ClientCommonNameCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldClientCommonName]
	return ok
}

// ResetClientCommonName resets all changes to the "client_common_name" field.
func (m *AuditLogMutation) ResetClientCommonName() {
	m.client_common_name = nil
	delete(m.clearedFields, auditlog.FieldClientCommonName)
}

// SetClientOrganization sets the "client_organization" field.
func (m *AuditLogMutation) SetClientOrganization(s string) {
	m.client_organization = &s
}

// ClientOrganization returns the value of the "client_organization" field in the mutation.
func (m *AuditLogMutation) ClientOrganization() (r string, exists bool) {
	v := m.client_organization
	if v == nil {
		return
	}
	return *v, true
}

// OldClientOrganization returns the old "client_organization" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldClientOrganization(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientOrganization is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientOrganization requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientOrganization: %w", err)
	}
	return oldValue.ClientOrganization, nil
}

// ClearClientOrganization clears the value of the "client_organization" field.
func (m *AuditLogMutation) ClearClientOrganization() {
	m.client_organization = nil
	m.clearedFields[auditlog.FieldClientOrganization] = struct{}{}
}

// ClientOrganizationCleared returns if the "client_organization" field was cleared in this mutation.
func (m *AuditLogMutation) ClientOrganizationCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldClientOrganization]
	return ok
}

// ResetClientOrganization resets all changes to the "client_organization" field.
func (m *AuditLogMutation) ResetClientOrganization() {
	m.client_organization = nil
	delete(m.clearedFields, auditlog.FieldClientOrganization)
}

// SetClientSerialNumber sets the "client_serial_number" field.
func (m *AuditLogMutation) SetClientSerialNumber(s string) {
	m.client_serial_number = &s
}

// ClientSerialNumber returns the value of the "client_serial_number" field in the mutation.
func (m *AuditLogMutation) ClientSerialNumber() (r string, exists bool) {
	v := m.client_serial_number
	if v == nil {
		return
	}
	return *v, true
}

// OldClientSerialNumber returns the old "client_serial_number" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldClientSerialNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientSerialNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientSerialNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientSerialNumber: %w", err)
	}
	return oldValue.ClientSerialNumber, nil
}

// ClearClientSerialNumber clears the value of the "client_serial_number" field.
func (m *AuditLogMutation) ClearClientSerialNumber() {
	m.client_serial_number = nil
	m.clearedFields[auditlog.FieldClientSerialNumber] = struct{}{}
}

// ClientSerialNumberCleared returns if the "client_serial_number" field was cleared in this mutation.
func (m *AuditLogMutation) ClientSerialNumberCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldClientSerialNumber]
	return ok
}

// ResetClientSerialNumber resets all changes to the "client_serial_number" field.
func (m *AuditLogMutation) ResetClientSerialNumber() {
	m.client_serial_number = nil
	delete(m.clearedFields, auditlog.FieldClientSerialNumber)
}

// SetIsAuthenticated sets the "is_authenticated" field.
func (m *AuditLogMutation) SetIsAuthenticated(b bool) {
	m.is_authenticated = &b
}

// IsAuthenticated returns the value of the "is_authenticated" field in the mutation.
func (m *AuditLogMutation) IsAuthenticated() (r bool, exists bool) {
	v := m.is_authenticated
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAuthenticated returns the old "is_authenticated" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldIsAuthenticated(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAuthenticated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAuthenticated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAuthenticated: %w", err)
	}
	return oldValue.IsAuthenticated, nil
}

// ResetIsAuthenticated resets all changes to the "is_authenticated" field.
func (m *AuditLogMutation) ResetIsAuthenticated() {
	m.is_authenticated = nil
}

// SetSuccess sets the "success" field.
func (m *AuditLogMutation) SetSuccess(b bool) {
	m.success = &b
}

// Success returns the value of the "success" field in the mutation.
func (m *AuditLogMutation) Success() (r bool, exists bool) {
	v := m.success
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccess returns the old "success" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldSuccess(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuccess is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuccess requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccess: %w", err)
	}
	return oldValue.Success, nil
}

// ResetSuccess resets all changes to the "success" field.
func (m *AuditLogMutation) ResetSuccess() {
	m.success = nil
}

// SetErrorCode sets the "error_code" field.
func (m *AuditLogMutation) SetErrorCode(i int32) {
	m.error_code = &i
	m.adderror_code = nil
}

// ErrorCode returns the value of the "error_code" field in the mutation.
func (m *AuditLogMutation) ErrorCode() (r int32, exists bool) {
	v := m.error_code
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorCode returns the old "error_code" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldErrorCode(ctx context.Context) (v *int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorCode: %w", err)
	}
	return oldValue.ErrorCode, nil
}

// AddErrorCode adds i to the "error_code" field.
func (m *AuditLogMutation) AddErrorCode(i int32) {
	if m.adderror_code != nil {
		*m.adderror_code += i
	} else {
		m.adderror_code = &i
	}
}

// AddedErrorCode returns the value that was added to the "error_code" field in this mutation.
func (m *AuditLogMutation) AddedErrorCode() (r int32, exists bool) {
	v := m.adderror_code
	if v == nil {
		return
	}
	return *v, true
}

// ClearErrorCode clears the value of the "error_code" field.
func (m *AuditLogMutation) ClearErrorCode() {
	m.error_code = nil
	m.adderror_code = nil
	m.clearedFields[auditlog.FieldErrorCode] = struct{}{}
}

// ErrorCodeCleared returns if the "error_code" field was cleared in this mutation.
func (m *AuditLogMutation) ErrorCodeCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldErrorCode]
	return ok
}

// ResetErrorCode resets all changes to the "error_code" field.
func (m *AuditLogMutation) ResetErrorCode() {
	m.error_code = nil
	m.adderror_code = nil
	delete(m.clearedFields, auditlog.FieldErrorCode)
}

// SetErrorMessage sets the "error_message" field.
func (m *AuditLogMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *AuditLogMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *AuditLogMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[auditlog.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *AuditLogMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *AuditLogMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, auditlog.FieldErrorMessage)
}

// SetLatencyMs sets the "latency_ms" field.
func (m *AuditLogMutation) SetLatencyMs(i int64) {
	m.latency_ms = &i
	m.addlatency_ms = nil
}

// LatencyMs returns the value of the "latency_ms" field in the mutation.
func (m *AuditLogMutation) LatencyMs() (r int64, exists bool) {
	v := m.latency_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldLatencyMs returns the old "latency_ms" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldLatencyMs(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatencyMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatencyMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatencyMs: %w", err)
	}
	return oldValue.LatencyMs, nil
}

// AddLatencyMs adds i to the "latency_ms" field.
func (m *AuditLogMutation) AddLatencyMs(i int64) {
	if m.addlatency_ms != nil {
		*m.addlatency_ms += i
	} else {
		m.addlatency_ms = &i
	}
}

// AddedLatencyMs returns the value that was added to the "latency_ms" field in this mutation.
func (m *AuditLogMutation) AddedLatencyMs() (r int64, exists bool) {
	v := m.addlatency_ms
	if v == nil {
		return
	}
	return *v, true
}

// ResetLatencyMs resets all changes to the "latency_ms" field.
func (m *AuditLogMutation) ResetLatencyMs() {
	m.latency_ms = nil
	m.addlatency_ms = nil
}

// SetPeerAddress sets the "peer_address" field.
func (m *AuditLogMutation) SetPeerAddress(s string) {
	m.peer_address = &s
}

// PeerAddress returns the value of the "peer_address" field in the mutation.
func (m *AuditLogMutation) PeerAddress() (r string, exists bool) {
	v := m.peer_address
	if v == nil {
		return
	}
	return *v, true
}

// OldPeerAddress returns the old "peer_address" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldPeerAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPeerAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPeerAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeerAddress: %w", err)
	}
	return oldValue.PeerAddress, nil
}

// ClearPeerAddress clears the value of the "peer_address" field.
func (m *AuditLogMutation) ClearPeerAddress() {
	m.peer_address = nil
	m.clearedFields[auditlog.FieldPeerAddress] = struct{}{}
}

// PeerAddressCleared returns if the "peer_address" field was cleared in this mutation.
func (m *AuditLogMutation) PeerAddressCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldPeerAddress]
	return ok
}

// ResetPeerAddress resets all changes to the "peer_address" field.
func (m *AuditLogMutation) ResetPeerAddress() {
	m.peer_address = nil
	delete(m.clearedFields, auditlog.FieldPeerAddress)
}

// SetGeoLocation sets the "geo_location" field.
func (m *AuditLogMutation) SetGeoLocation(value map[string]string) {
	m.geo_location = &value
}

// GeoLocation returns the value of the "geo_location" field in the mutation.
func (m *AuditLogMutation) GeoLocation() (r map[string]string, exists bool) {
	v := m.geo_location
	if v == nil {
		return
	}
	return *v, true
}

// OldGeoLocation returns the old "geo_location" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldGeoLocation(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGeoLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGeoLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGeoLocation: %w", err)
	}
	return oldValue.GeoLocation, nil
}

// ClearGeoLocation clears the value of the "geo_location" field.
func (m *AuditLogMutation) ClearGeoLocation() {
	m.geo_location = nil
	m.clearedFields[auditlog.FieldGeoLocation] = struct{}{}
}

// GeoLocationCleared returns if the "geo_location" field was cleared in this mutation.
func (m *AuditLogMutation) GeoLocationCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldGeoLocation]
	return ok
}

// ResetGeoLocation resets all changes to the "geo_location" field.
func (m *AuditLogMutation) ResetGeoLocation() {
	m.geo_location = nil
	delete(m.clearedFields, auditlog.FieldGeoLocation)
}

// SetLogHash sets the "log_hash" field.
func (m *AuditLogMutation) SetLogHash(s string) {
	m.log_hash = &s
}

// LogHash returns the value of the "log_hash" field in the mutation.
func (m *AuditLogMutation) LogHash() (r string, exists bool) {
	v := m.log_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldLogHash returns the old "log_hash" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldLogHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogHash: %w", err)
	}
	return oldValue.LogHash, nil
}

// ClearLogHash clears the value of the "log_hash" field.
func (m *AuditLogMutation) ClearLogHash() {
	m.log_hash = nil
	m.clearedFields[auditlog.FieldLogHash] = struct{}{}
}

// LogHashCleared returns if the "log_hash" field was cleared in this mutation.
func (m *AuditLogMutation) LogHashCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldLogHash]
	return ok
}

// ResetLogHash resets all changes to the "log_hash" field.
func (m *AuditLogMutation) ResetLogHash() {
	m.log_hash = nil
	delete(m.clearedFields, auditlog.FieldLogHash)
}

// SetSignature sets the "signature" field.
func (m *AuditLogMutation) SetSignature(b []byte) {
	m.signature = &b
}

// Signature returns the value of the "signature" field in the mutation.
func (m *AuditLogMutation) Signature() (r []byte, exists bool) {
	v := m.signature
	if v == nil {
		return
	}
	return *v, true
}

// OldSignature returns the old "signature" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldSignature(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignature: %w", err)
	}
	return oldValue.Signature, nil
}

// ClearSignature clears the value of the "signature" field.
func (m *AuditLogMutation) ClearSignature() {
	m.signature = nil
	m.clearedFields[auditlog.FieldSignature] = struct{}{}
}

// SignatureCleared returns if the "signature" field was cleared in this mutation.
func (m *AuditLogMutation) SignatureCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldSignature]
	return ok
}

// ResetSignature resets all changes to the "signature" field.
func (m *AuditLogMutation) ResetSignature() {
	m.signature = nil
	delete(m.clearedFields, auditlog.FieldSignature)
}

// SetMetadata sets the "metadata" field.
func (m *AuditLogMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *AuditLogMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *AuditLogMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[auditlog.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *AuditLogMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *AuditLogMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, auditlog.FieldMetadata)
}

// Where appends a list predicates to the AuditLogMutation builder.
func (m *AuditLogMutation) Where(ps ...predicate.AuditLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuditLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuditLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AuditLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuditLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuditLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AuditLog).
func (m *AuditLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuditLogMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.create_time != nil {
		fields = append(fields, auditlog.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, auditlog.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, auditlog.FieldDeleteTime)
	}
	if m.tenant_id != nil {
		fields = append(fields, auditlog.FieldTenantID)
	}
	if m.audit_id != nil {
		fields = append(fields, auditlog.FieldAuditID)
	}
	if m.request_id != nil {
		fields = append(fields, auditlog.FieldRequestID)
	}
	if m.operation != nil {
		fields = append(fields, auditlog.FieldOperation)
	}
	if m.service_name != nil {
		fields = append(fields, auditlog.FieldServiceName)
	}
	if m.client_id != nil {
		fields = append(fields, auditlog.FieldClientID)
	}
	if m.client_common_name != nil {
		fields = append(fields, auditlog.FieldClientCommonName)
	}
	if m.client_organization != nil {
		fields = append(fields, auditlog.FieldClientOrganization)
	}
	if m.client_serial_number != nil {
		fields = append(fields, auditlog.FieldClientSerialNumber)
	}
	if m.is_authenticated != nil {
		fields = append(fields, auditlog.FieldIsAuthenticated)
	}
	if m.success != nil {
		fields = append(fields, auditlog.FieldSuccess)
	}
	if m.error_code != nil {
		fields = append(fields, auditlog.FieldErrorCode)
	}
	if m.error_message != nil {
		fields = append(fields, auditlog.FieldErrorMessage)
	}
	if m.latency_ms != nil {
		fields = append(fields, auditlog.FieldLatencyMs)
	}
	if m.peer_address != nil {
		fields = append(fields, auditlog.FieldPeerAddress)
	}
	if m.geo_location != nil {
		fields = append(fields, auditlog.FieldGeoLocation)
	}
	if m.log_hash != nil {
		fields = append(fields, auditlog.FieldLogHash)
	}
	if m.signature != nil {
		fields = append(fields, auditlog.FieldSignature)
	}
	if m.metadata != nil {
		fields = append(fields, auditlog.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuditLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case auditlog.FieldCreateTime:
		return m.CreateTime()
	case auditlog.FieldUpdateTime:
		return m.UpdateTime()
	case auditlog.FieldDeleteTime:
		return m.DeleteTime()
	case auditlog.FieldTenantID:
		return m.TenantID()
	case auditlog.FieldAuditID:
		return m.AuditID()
	case auditlog.FieldRequestID:
		return m.RequestID()
	case auditlog.FieldOperation:
		return m.Operation()
	case auditlog.FieldServiceName:
		return m.ServiceName()
	case auditlog.FieldClientID:
		return m.ClientID()
	case auditlog.FieldClientCommonName:
		return m.ClientCommonName()
	case auditlog.FieldClientOrganization:
		return m.ClientOrganization()
	case auditlog.FieldClientSerialNumber:
		return m.ClientSerialNumber()
	case auditlog.FieldIsAuthenticated:
		return m.IsAuthenticated()
	case auditlog.FieldSuccess:
		return m.Success()
	case auditlog.FieldErrorCode:
		return m.ErrorCode()
	case auditlog.FieldErrorMessage:
		return m.ErrorMessage()
	case auditlog.FieldLatencyMs:
		return m.LatencyMs()
	case auditlog.FieldPeerAddress:
		return m.PeerAddress()
	case auditlog.FieldGeoLocation:
		return m.GeoLocation()
	case auditlog.FieldLogHash:
		return m.LogHash()
	case auditlog.FieldSignature:
		return m.Signature()
	case auditlog.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuditLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case auditlog.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case auditlog.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case auditlog.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case auditlog.FieldTenantID:
		return m.OldTenantID(ctx)
	case auditlog.FieldAuditID:
		return m.OldAuditID(ctx)
	case auditlog.FieldRequestID:
		return m.OldRequestID(ctx)
	case auditlog.FieldOperation:
		return m.OldOperation(ctx)
	case auditlog.FieldServiceName:
		return m.OldServiceName(ctx)
	case auditlog.FieldClientID:
		return m.OldClientID(ctx)
	case auditlog.FieldClientCommonName:
		return m.OldClientCommonName(ctx)
	case auditlog.FieldClientOrganization:
		return m.OldClientOrganization(ctx)
	case auditlog.FieldClientSerialNumber:
		return m.OldClientSerialNumber(ctx)
	case auditlog.FieldIsAuthenticated:
		return m.OldIsAuthenticated(ctx)
	case auditlog.FieldSuccess:
		return m.OldSuccess(ctx)
	case auditlog.FieldErrorCode:
		return m.OldErrorCode(ctx)
	case auditlog.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case auditlog.FieldLatencyMs:
		return m.OldLatencyMs(ctx)
	case auditlog.FieldPeerAddress:
		return m.OldPeerAddress(ctx)
	case auditlog.FieldGeoLocation:
		return m.OldGeoLocation(ctx)
	case auditlog.FieldLogHash:
		return m.OldLogHash(ctx)
	case auditlog.FieldSignature:
		return m.OldSignature(ctx)
	case auditlog.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown AuditLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case auditlog.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case auditlog.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case auditlog.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case auditlog.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case auditlog.FieldAuditID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuditID(v)
		return nil
	case auditlog.FieldRequestID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestID(v)
		return nil
	case auditlog.FieldOperation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case auditlog.FieldServiceName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceName(v)
		return nil
	case auditlog.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case auditlog.FieldClientCommonName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientCommonName(v)
		return nil
	case auditlog.FieldClientOrganization:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientOrganization(v)
		return nil
	case auditlog.FieldClientSerialNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientSerialNumber(v)
		return nil
	case auditlog.FieldIsAuthenticated:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAuthenticated(v)
		return nil
	case auditlog.FieldSuccess:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccess(v)
		return nil
	case auditlog.FieldErrorCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorCode(v)
		return nil
	case auditlog.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case auditlog.FieldLatencyMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatencyMs(v)
		return nil
	case auditlog.FieldPeerAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeerAddress(v)
		return nil
	case auditlog.FieldGeoLocation:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGeoLocation(v)
		return nil
	case auditlog.FieldLogHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogHash(v)
		return nil
	case auditlog.FieldSignature:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignature(v)
		return nil
	case auditlog.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown AuditLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuditLogMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, auditlog.FieldTenantID)
	}
	if m.adderror_code != nil {
		fields = append(fields, auditlog.FieldErrorCode)
	}
	if m.addlatency_ms != nil {
		fields = append(fields, auditlog.FieldLatencyMs)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuditLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case auditlog.FieldTenantID:
		return m.AddedTenantID()
	case auditlog.FieldErrorCode:
		return m.AddedErrorCode()
	case auditlog.FieldLatencyMs:
		return m.AddedLatencyMs()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case auditlog.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case auditlog.FieldErrorCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddErrorCode(v)
		return nil
	case auditlog.FieldLatencyMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLatencyMs(v)
		return nil
	}
	return fmt.Errorf("unknown AuditLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuditLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(auditlog.FieldCreateTime) {
		fields = append(fields, auditlog.FieldCreateTime)
	}
	if m.FieldCleared(auditlog.FieldUpdateTime) {
		fields = append(fields, auditlog.FieldUpdateTime)
	}
	if m.FieldCleared(auditlog.FieldDeleteTime) {
		fields = append(fields, auditlog.FieldDeleteTime)
	}
	if m.FieldCleared(auditlog.FieldTenantID) {
		fields = append(fields, auditlog.FieldTenantID)
	}
	if m.FieldCleared(auditlog.FieldRequestID) {
		fields = append(fields, auditlog.FieldRequestID)
	}
	if m.FieldCleared(auditlog.FieldClientID) {
		fields = append(fields, auditlog.FieldClientID)
	}
	if m.FieldCleared(auditlog.FieldClientCommonName) {
		fields = append(fields, auditlog.FieldClientCommonName)
	}
	if m.FieldCleared(auditlog.FieldClientOrganization) {
		fields = append(fields, auditlog.FieldClientOrganization)
	}
	if m.FieldCleared(auditlog.FieldClientSerialNumber) {
		fields = append(fields, auditlog.FieldClientSerialNumber)
	}
	if m.FieldCleared(auditlog.FieldErrorCode) {
		fields = append(fields, auditlog.FieldErrorCode)
	}
	if m.FieldCleared(auditlog.FieldErrorMessage) {
		fields = append(fields, auditlog.FieldErrorMessage)
	}
	if m.FieldCleared(auditlog.FieldPeerAddress) {
		fields = append(fields, auditlog.FieldPeerAddress)
	}
	if m.FieldCleared(auditlog.FieldGeoLocation) {
		fields = append(fields, auditlog.FieldGeoLocation)
	}
	if m.FieldCleared(auditlog.FieldLogHash) {
		fields = append(fields, auditlog.FieldLogHash)
	}
	if m.FieldCleared(auditlog.FieldSignature) {
		fields = append(fields, auditlog.FieldSignature)
	}
	if m.FieldCleared(auditlog.FieldMetadata) {
		fields = append(fields, auditlog.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuditLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuditLogMutation) ClearField(name string) error {
	switch name {
	case auditlog.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case auditlog.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	case auditlog.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case auditlog.FieldTenantID:
		m.ClearTenantID()
		return nil
	case auditlog.FieldRequestID:
		m.ClearRequestID()
		return nil
	case auditlog.FieldClientID:
		m.ClearClientID()
		return nil
	case auditlog.FieldClientCommonName:
		m.ClearClientCommonName()
		return nil
	case auditlog.FieldClientOrganization:
		m.ClearClientOrganization()
		return nil
	case auditlog.FieldClientSerialNumber:
		m.ClearClientSerialNumber()
		return nil
	case auditlog.FieldErrorCode:
		m.ClearErrorCode()
		return nil
	case auditlog.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case auditlog.FieldPeerAddress:
		m.ClearPeerAddress()
		return nil
	case auditlog.FieldGeoLocation:
		m.ClearGeoLocation()
		return nil
	case auditlog.FieldLogHash:
		m.ClearLogHash()
		return nil
	case auditlog.FieldSignature:
		m.ClearSignature()
		return nil
	case auditlog.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown AuditLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuditLogMutation) ResetField(name string) error {
	switch name {
	case auditlog.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case auditlog.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case auditlog.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case auditlog.FieldTenantID:
		m.ResetTenantID()
		return nil
	case auditlog.FieldAuditID:
		m.ResetAuditID()
		return nil
	case auditlog.FieldRequestID:
		m.ResetRequestID()
		return nil
	case auditlog.FieldOperation:
		m.ResetOperation()
		return nil
	case auditlog.FieldServiceName:
		m.ResetServiceName()
		return nil
	case auditlog.FieldClientID:
		m.ResetClientID()
		return nil
	case auditlog.FieldClientCommonName:
		m.ResetClientCommonName()
		return nil
	case auditlog.FieldClientOrganization:
		m.ResetClientOrganization()
		return nil
	case auditlog.FieldClientSerialNumber:
		m.ResetClientSerialNumber()
		return nil
	case auditlog.FieldIsAuthenticated:
		m.ResetIsAuthenticated()
		return nil
	case auditlog.FieldSuccess:
		m.ResetSuccess()
		return nil
	case auditlog.FieldErrorCode:
		m.ResetErrorCode()
		return nil
	case auditlog.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case auditlog.FieldLatencyMs:
		m.ResetLatencyMs()
		return nil
	case auditlog.FieldPeerAddress:
		m.ResetPeerAddress()
		return nil
	case auditlog.FieldGeoLocation:
		m.ResetGeoLocation()
		return nil
	case auditlog.FieldLogHash:
		m.ResetLogHash()
		return nil
	case auditlog.FieldSignature:
		m.ResetSignature()
		return nil
	case auditlog.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown AuditLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuditLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuditLogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuditLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuditLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuditLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuditLogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuditLogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AuditLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuditLogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AuditLog edge %s", name)
}

// FolderMutation represents an operation that mutates the Folder nodes in the graph.
type FolderMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	create_by          *uint32
	addcreate_by       *int32
	create_time        *time.Time
	update_time        *time.Time
	delete_time        *time.Time
	tenant_id          *uint32
	addtenant_id       *int32
	name               *string
	_path              *string
	description        *string
	depth              *int32
	adddepth           *int32
	clearedFields      map[string]struct{}
	parent             *string
	clearedparent      bool
	children           map[string]struct{}
	removedchildren    map[string]struct{}
	clearedchildren    bool
	secrets            map[string]struct{}
	removedsecrets     map[string]struct{}
	clearedsecrets     bool
	permissions        map[int]struct{}
	removedpermissions map[int]struct{}
	clearedpermissions bool
	done               bool
	oldValue           func(context.Context) (*Folder, error)
	predicates         []predicate.Folder
}

var _ ent.Mutation = (*FolderMutation)(nil)

// folderOption allows management of the mutation configuration using functional options.
type folderOption func(*FolderMutation)

// newFolderMutation creates new mutation for the Folder entity.
func newFolderMutation(c config, op Op, opts ...folderOption) *FolderMutation {
	m := &FolderMutation{
		config:        c,
		op:            op,
		typ:           TypeFolder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFolderID sets the ID field of the mutation.
func withFolderID(id string) folderOption {
	return func(m *FolderMutation) {
		var (
			err   error
			once  sync.Once
			value *Folder
		)
		m.oldValue = func(ctx context.Context) (*Folder, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Folder.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFolder sets the old Folder of the mutation.
func withFolder(node *Folder) folderOption {
	return func(m *FolderMutation) {
		m.oldValue = func(context.Context) (*Folder, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FolderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FolderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Folder entities.
func (m *FolderMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FolderMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FolderMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Folder.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateBy sets the "create_by" field.
func (m *FolderMutation) SetCreateBy(u uint32) {
	m.create_by = &u
	m.addcreate_by = nil
}

// CreateBy returns the value of the "create_by" field in the mutation.
func (m *FolderMutation) CreateBy() (r uint32, exists bool) {
	v := m.create_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "create_by" field's value of the Folder entity.
// If the Folder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FolderMutation) OldCreateBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds u to the "create_by" field.
func (m *FolderMutation) AddCreateBy(u int32) {
	if m.addcreate_by != nil {
		*m.addcreate_by += u
	} else {
		m.addcreate_by = &u
	}
}

// AddedCreateBy returns the value that was added to the "create_by" field in this mutation.
func (m *FolderMutation) AddedCreateBy() (r int32, exists bool) {
	v := m.addcreate_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateBy clears the value of the "create_by" field.
func (m *FolderMutation) ClearCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	m.clearedFields[folder.FieldCreateBy] = struct{}{}
}

// CreateByCleared returns if the "create_by" field was cleared in this mutation.
func (m *FolderMutation) CreateByCleared() bool {
	_, ok := m.clearedFields[folder.FieldCreateBy]
	return ok
}

// ResetCreateBy resets all changes to the "create_by" field.
func (m *FolderMutation) ResetCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	delete(m.clearedFields, folder.FieldCreateBy)
}

// SetCreateTime sets the "create_time" field.
func (m *FolderMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *FolderMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Folder entity.
// If the Folder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FolderMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *FolderMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[folder.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *FolderMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[folder.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *FolderMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, folder.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *FolderMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *FolderMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Folder entity.
// If the Folder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FolderMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *FolderMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[folder.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *FolderMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[folder.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *FolderMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, folder.FieldUpdateTime)
}

// SetDeleteTime sets the "delete_time" field.
func (m *FolderMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *FolderMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the Folder entity.
// If the Folder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FolderMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *FolderMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[folder.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *FolderMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[folder.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *FolderMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, folder.FieldDeleteTime)
}

// SetTenantID sets the "tenant_id" field.
func (m *FolderMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *FolderMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Folder entity.
// If the Folder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FolderMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *FolderMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *FolderMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *FolderMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[folder.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *FolderMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[folder.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *FolderMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, folder.FieldTenantID)
}

// SetParentID sets the "parent_id" field.
func (m *FolderMutation) SetParentID(s string) {
	m.parent = &s
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *FolderMutation) ParentID() (r string, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Folder entity.
// If the Folder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FolderMutation) OldParentID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *FolderMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[folder.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *FolderMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[folder.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *FolderMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, folder.FieldParentID)
}

// SetName sets the "name" field.
func (m *FolderMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FolderMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Folder entity.
// If the Folder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FolderMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FolderMutation) ResetName() {
	m.name = nil
}

// SetPath sets the "path" field.
func (m *FolderMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *FolderMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the Folder entity.
// If the Folder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FolderMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *FolderMutation) ResetPath() {
	m._path = nil
}

// SetDescription sets the "description" field.
func (m *FolderMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *FolderMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Folder entity.
// If the Folder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FolderMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *FolderMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[folder.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *FolderMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[folder.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *FolderMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, folder.FieldDescription)
}

// SetDepth sets the "depth" field.
func (m *FolderMutation) SetDepth(i int32) {
	m.depth = &i
	m.adddepth = nil
}

// Depth returns the value of the "depth" field in the mutation.
func (m *FolderMutation) Depth() (r int32, exists bool) {
	v := m.depth
	if v == nil {
		return
	}
	return *v, true
}

// OldDepth returns the old "depth" field's value of the Folder entity.
// If the Folder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FolderMutation) OldDepth(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepth: %w", err)
	}
	return oldValue.Depth, nil
}

// AddDepth adds i to the "depth" field.
func (m *FolderMutation) AddDepth(i int32) {
	if m.adddepth != nil {
		*m.adddepth += i
	} else {
		m.adddepth = &i
	}
}

// AddedDepth returns the value that was added to the "depth" field in this mutation.
func (m *FolderMutation) AddedDepth() (r int32, exists bool) {
	v := m.adddepth
	if v == nil {
		return
	}
	return *v, true
}

// ResetDepth resets all changes to the "depth" field.
func (m *FolderMutation) ResetDepth() {
	m.depth = nil
	m.adddepth = nil
}

// ClearParent clears the "parent" edge to the Folder entity.
func (m *FolderMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[folder.FieldParentID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the Folder entity was cleared.
func (m *FolderMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *FolderMutation) ParentIDs() (ids []string) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *FolderMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the Folder entity by ids.
func (m *FolderMutation) AddChildIDs(ids ...string) {
	if m.children == nil {
		m.children = make(map[string]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Folder entity.
func (m *FolderMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Folder entity was cleared.
func (m *FolderMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Folder entity by IDs.
func (m *FolderMutation) RemoveChildIDs(ids ...string) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Folder entity.
func (m *FolderMutation) RemovedChildrenIDs() (ids []string) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *FolderMutation) ChildrenIDs() (ids []string) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *FolderMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddSecretIDs adds the "secrets" edge to the Secret entity by ids.
func (m *FolderMutation) AddSecretIDs(ids ...string) {
	if m.secrets == nil {
		m.secrets = make(map[string]struct{})
	}
	for i := range ids {
		m.secrets[ids[i]] = struct{}{}
	}
}

// ClearSecrets clears the "secrets" edge to the Secret entity.
func (m *FolderMutation) ClearSecrets() {
	m.clearedsecrets = true
}

// SecretsCleared reports if the "secrets" edge to the Secret entity was cleared.
func (m *FolderMutation) SecretsCleared() bool {
	return m.clearedsecrets
}

// RemoveSecretIDs removes the "secrets" edge to the Secret entity by IDs.
func (m *FolderMutation) RemoveSecretIDs(ids ...string) {
	if m.removedsecrets == nil {
		m.removedsecrets = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.secrets, ids[i])
		m.removedsecrets[ids[i]] = struct{}{}
	}
}

// RemovedSecrets returns the removed IDs of the "secrets" edge to the Secret entity.
func (m *FolderMutation) RemovedSecretsIDs() (ids []string) {
	for id := range m.removedsecrets {
		ids = append(ids, id)
	}
	return
}

// SecretsIDs returns the "secrets" edge IDs in the mutation.
func (m *FolderMutation) SecretsIDs() (ids []string) {
	for id := range m.secrets {
		ids = append(ids, id)
	}
	return
}

// ResetSecrets resets all changes to the "secrets" edge.
func (m *FolderMutation) ResetSecrets() {
	m.secrets = nil
	m.clearedsecrets = false
	m.removedsecrets = nil
}

// AddPermissionIDs adds the "permissions" edge to the Permission entity by ids.
func (m *FolderMutation) AddPermissionIDs(ids ...int) {
	if m.permissions == nil {
		m.permissions = make(map[int]struct{})
	}
	for i := range ids {
		m.permissions[ids[i]] = struct{}{}
	}
}

// ClearPermissions clears the "permissions" edge to the Permission entity.
func (m *FolderMutation) ClearPermissions() {
	m.clearedpermissions = true
}

// PermissionsCleared reports if the "permissions" edge to the Permission entity was cleared.
func (m *FolderMutation) PermissionsCleared() bool {
	return m.clearedpermissions
}

// RemovePermissionIDs removes the "permissions" edge to the Permission entity by IDs.
func (m *FolderMutation) RemovePermissionIDs(ids ...int) {
	if m.removedpermissions == nil {
		m.removedpermissions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.permissions, ids[i])
		m.removedpermissions[ids[i]] = struct{}{}
	}
}

// RemovedPermissions returns the removed IDs of the "permissions" edge to the Permission entity.
func (m *FolderMutation) RemovedPermissionsIDs() (ids []int) {
	for id := range m.removedpermissions {
		ids = append(ids, id)
	}
	return
}

// PermissionsIDs returns the "permissions" edge IDs in the mutation.
func (m *FolderMutation) PermissionsIDs() (ids []int) {
	for id := range m.permissions {
		ids = append(ids, id)
	}
	return
}

// ResetPermissions resets all changes to the "permissions" edge.
func (m *FolderMutation) ResetPermissions() {
	m.permissions = nil
	m.clearedpermissions = false
	m.removedpermissions = nil
}

// Where appends a list predicates to the FolderMutation builder.
func (m *FolderMutation) Where(ps ...predicate.Folder) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FolderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FolderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Folder, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FolderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FolderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Folder).
func (m *FolderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FolderMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.create_by != nil {
		fields = append(fields, folder.FieldCreateBy)
	}
	if m.create_time != nil {
		fields = append(fields, folder.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, folder.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, folder.FieldDeleteTime)
	}
	if m.tenant_id != nil {
		fields = append(fields, folder.FieldTenantID)
	}
	if m.parent != nil {
		fields = append(fields, folder.FieldParentID)
	}
	if m.name != nil {
		fields = append(fields, folder.FieldName)
	}
	if m._path != nil {
		fields = append(fields, folder.FieldPath)
	}
	if m.description != nil {
		fields = append(fields, folder.FieldDescription)
	}
	if m.depth != nil {
		fields = append(fields, folder.FieldDepth)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FolderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case folder.FieldCreateBy:
		return m.CreateBy()
	case folder.FieldCreateTime:
		return m.CreateTime()
	case folder.FieldUpdateTime:
		return m.UpdateTime()
	case folder.FieldDeleteTime:
		return m.DeleteTime()
	case folder.FieldTenantID:
		return m.TenantID()
	case folder.FieldParentID:
		return m.ParentID()
	case folder.FieldName:
		return m.Name()
	case folder.FieldPath:
		return m.Path()
	case folder.FieldDescription:
		return m.Description()
	case folder.FieldDepth:
		return m.Depth()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FolderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case folder.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case folder.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case folder.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case folder.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case folder.FieldTenantID:
		return m.OldTenantID(ctx)
	case folder.FieldParentID:
		return m.OldParentID(ctx)
	case folder.FieldName:
		return m.OldName(ctx)
	case folder.FieldPath:
		return m.OldPath(ctx)
	case folder.FieldDescription:
		return m.OldDescription(ctx)
	case folder.FieldDepth:
		return m.OldDepth(ctx)
	}
	return nil, fmt.Errorf("unknown Folder field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FolderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case folder.FieldCreateBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case folder.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case folder.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case folder.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case folder.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case folder.FieldParentID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case folder.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case folder.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case folder.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case folder.FieldDepth:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepth(v)
		return nil
	}
	return fmt.Errorf("unknown Folder field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FolderMutation) AddedFields() []string {
	var fields []string
	if m.addcreate_by != nil {
		fields = append(fields, folder.FieldCreateBy)
	}
	if m.addtenant_id != nil {
		fields = append(fields, folder.FieldTenantID)
	}
	if m.adddepth != nil {
		fields = append(fields, folder.FieldDepth)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FolderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case folder.FieldCreateBy:
		return m.AddedCreateBy()
	case folder.FieldTenantID:
		return m.AddedTenantID()
	case folder.FieldDepth:
		return m.AddedDepth()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FolderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case folder.FieldCreateBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case folder.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case folder.FieldDepth:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDepth(v)
		return nil
	}
	return fmt.Errorf("unknown Folder numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FolderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(folder.FieldCreateBy) {
		fields = append(fields, folder.FieldCreateBy)
	}
	if m.FieldCleared(folder.FieldCreateTime) {
		fields = append(fields, folder.FieldCreateTime)
	}
	if m.FieldCleared(folder.FieldUpdateTime) {
		fields = append(fields, folder.FieldUpdateTime)
	}
	if m.FieldCleared(folder.FieldDeleteTime) {
		fields = append(fields, folder.FieldDeleteTime)
	}
	if m.FieldCleared(folder.FieldTenantID) {
		fields = append(fields, folder.FieldTenantID)
	}
	if m.FieldCleared(folder.FieldParentID) {
		fields = append(fields, folder.FieldParentID)
	}
	if m.FieldCleared(folder.FieldDescription) {
		fields = append(fields, folder.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FolderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FolderMutation) ClearField(name string) error {
	switch name {
	case folder.FieldCreateBy:
		m.ClearCreateBy()
		return nil
	case folder.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case folder.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	case folder.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case folder.FieldTenantID:
		m.ClearTenantID()
		return nil
	case folder.FieldParentID:
		m.ClearParentID()
		return nil
	case folder.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Folder nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FolderMutation) ResetField(name string) error {
	switch name {
	case folder.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case folder.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case folder.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case folder.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case folder.FieldTenantID:
		m.ResetTenantID()
		return nil
	case folder.FieldParentID:
		m.ResetParentID()
		return nil
	case folder.FieldName:
		m.ResetName()
		return nil
	case folder.FieldPath:
		m.ResetPath()
		return nil
	case folder.FieldDescription:
		m.ResetDescription()
		return nil
	case folder.FieldDepth:
		m.ResetDepth()
		return nil
	}
	return fmt.Errorf("unknown Folder field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FolderMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.parent != nil {
		edges = append(edges, folder.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, folder.EdgeChildren)
	}
	if m.secrets != nil {
		edges = append(edges, folder.EdgeSecrets)
	}
	if m.permissions != nil {
		edges = append(edges, folder.EdgePermissions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FolderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case folder.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case folder.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case folder.EdgeSecrets:
		ids := make([]ent.Value, 0, len(m.secrets))
		for id := range m.secrets {
			ids = append(ids, id)
		}
		return ids
	case folder.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.permissions))
		for id := range m.permissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FolderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedchildren != nil {
		edges = append(edges, folder.EdgeChildren)
	}
	if m.removedsecrets != nil {
		edges = append(edges, folder.EdgeSecrets)
	}
	if m.removedpermissions != nil {
		edges = append(edges, folder.EdgePermissions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FolderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case folder.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case folder.EdgeSecrets:
		ids := make([]ent.Value, 0, len(m.removedsecrets))
		for id := range m.removedsecrets {
			ids = append(ids, id)
		}
		return ids
	case folder.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.removedpermissions))
		for id := range m.removedpermissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FolderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedparent {
		edges = append(edges, folder.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, folder.EdgeChildren)
	}
	if m.clearedsecrets {
		edges = append(edges, folder.EdgeSecrets)
	}
	if m.clearedpermissions {
		edges = append(edges, folder.EdgePermissions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FolderMutation) EdgeCleared(name string) bool {
	switch name {
	case folder.EdgeParent:
		return m.clearedparent
	case folder.EdgeChildren:
		return m.clearedchildren
	case folder.EdgeSecrets:
		return m.clearedsecrets
	case folder.EdgePermissions:
		return m.clearedpermissions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FolderMutation) ClearEdge(name string) error {
	switch name {
	case folder.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Folder unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FolderMutation) ResetEdge(name string) error {
	switch name {
	case folder.EdgeParent:
		m.ResetParent()
		return nil
	case folder.EdgeChildren:
		m.ResetChildren()
		return nil
	case folder.EdgeSecrets:
		m.ResetSecrets()
		return nil
	case folder.EdgePermissions:
		m.ResetPermissions()
		return nil
	}
	return fmt.Errorf("unknown Folder edge %s", name)
}

// PermissionMutation represents an operation that mutates the Permission nodes in the graph.
type PermissionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	create_time   *time.Time
	update_time   *time.Time
	delete_time   *time.Time
	tenant_id     *uint32
	addtenant_id  *int32
	resource_type *permission.ResourceType
	resource_id   *string
	relation      *permission.Relation
	subject_type  *permission.SubjectType
	subject_id    *string
	granted_by    *uint32
	addgranted_by *int32
	expires_at    *time.Time
	clearedFields map[string]struct{}
	folder        *string
	clearedfolder bool
	secret        *string
	clearedsecret bool
	done          bool
	oldValue      func(context.Context) (*Permission, error)
	predicates    []predicate.Permission
}

var _ ent.Mutation = (*PermissionMutation)(nil)

// permissionOption allows management of the mutation configuration using functional options.
type permissionOption func(*PermissionMutation)

// newPermissionMutation creates new mutation for the Permission entity.
func newPermissionMutation(c config, op Op, opts ...permissionOption) *PermissionMutation {
	m := &PermissionMutation{
		config:        c,
		op:            op,
		typ:           TypePermission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPermissionID sets the ID field of the mutation.
func withPermissionID(id int) permissionOption {
	return func(m *PermissionMutation) {
		var (
			err   error
			once  sync.Once
			value *Permission
		)
		m.oldValue = func(ctx context.Context) (*Permission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Permission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPermission sets the old Permission of the mutation.
func withPermission(node *Permission) permissionOption {
	return func(m *PermissionMutation) {
		m.oldValue = func(context.Context) (*Permission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PermissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PermissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PermissionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PermissionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Permission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *PermissionMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *PermissionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *PermissionMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[permission.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *PermissionMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[permission.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *PermissionMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, permission.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *PermissionMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *PermissionMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *PermissionMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[permission.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *PermissionMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[permission.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *PermissionMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, permission.FieldUpdateTime)
}

// SetDeleteTime sets the "delete_time" field.
func (m *PermissionMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *PermissionMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *PermissionMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[permission.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *PermissionMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[permission.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *PermissionMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, permission.FieldDeleteTime)
}

// SetTenantID sets the "tenant_id" field.
func (m *PermissionMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *PermissionMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *PermissionMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *PermissionMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *PermissionMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[permission.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *PermissionMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[permission.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *PermissionMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, permission.FieldTenantID)
}

// SetResourceType sets the "resource_type" field.
func (m *PermissionMutation) SetResourceType(pt permission.ResourceType) {
	m.resource_type = &pt
}

// ResourceType returns the value of the "resource_type" field in the mutation.
func (m *PermissionMutation) ResourceType() (r permission.ResourceType, exists bool) {
	v := m.resource_type
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceType returns the old "resource_type" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldResourceType(ctx context.Context) (v permission.ResourceType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceType: %w", err)
	}
	return oldValue.ResourceType, nil
}

// ResetResourceType resets all changes to the "resource_type" field.
func (m *PermissionMutation) ResetResourceType() {
	m.resource_type = nil
}

// SetResourceID sets the "resource_id" field.
func (m *PermissionMutation) SetResourceID(s string) {
	m.resource_id = &s
}

// ResourceID returns the value of the "resource_id" field in the mutation.
func (m *PermissionMutation) ResourceID() (r string, exists bool) {
	v := m.resource_id
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceID returns the old "resource_id" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldResourceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceID: %w", err)
	}
	return oldValue.ResourceID, nil
}

// ResetResourceID resets all changes to the "resource_id" field.
func (m *PermissionMutation) ResetResourceID() {
	m.resource_id = nil
}

// SetRelation sets the "relation" field.
func (m *PermissionMutation) SetRelation(pe permission.Relation) {
	m.relation = &pe
}

// Relation returns the value of the "relation" field in the mutation.
func (m *PermissionMutation) Relation() (r permission.Relation, exists bool) {
	v := m.relation
	if v == nil {
		return
	}
	return *v, true
}

// OldRelation returns the old "relation" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldRelation(ctx context.Context) (v permission.Relation, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelation: %w", err)
	}
	return oldValue.Relation, nil
}

// ResetRelation resets all changes to the "relation" field.
func (m *PermissionMutation) ResetRelation() {
	m.relation = nil
}

// SetSubjectType sets the "subject_type" field.
func (m *PermissionMutation) SetSubjectType(pt permission.SubjectType) {
	m.subject_type = &pt
}

// SubjectType returns the value of the "subject_type" field in the mutation.
func (m *PermissionMutation) SubjectType() (r permission.SubjectType, exists bool) {
	v := m.subject_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectType returns the old "subject_type" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldSubjectType(ctx context.Context) (v permission.SubjectType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubjectType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubjectType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectType: %w", err)
	}
	return oldValue.SubjectType, nil
}

// ResetSubjectType resets all changes to the "subject_type" field.
func (m *PermissionMutation) ResetSubjectType() {
	m.subject_type = nil
}

// SetSubjectID sets the "subject_id" field.
func (m *PermissionMutation) SetSubjectID(s string) {
	m.subject_id = &s
}

// SubjectID returns the value of the "subject_id" field in the mutation.
func (m *PermissionMutation) SubjectID() (r string, exists bool) {
	v := m.subject_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSubjectID returns the old "subject_id" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldSubjectID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubjectID: %w", err)
	}
	return oldValue.SubjectID, nil
}

// ResetSubjectID resets all changes to the "subject_id" field.
func (m *PermissionMutation) ResetSubjectID() {
	m.subject_id = nil
}

// SetGrantedBy sets the "granted_by" field.
func (m *PermissionMutation) SetGrantedBy(u uint32) {
	m.granted_by = &u
	m.addgranted_by = nil
}

// GrantedBy returns the value of the "granted_by" field in the mutation.
func (m *PermissionMutation) GrantedBy() (r uint32, exists bool) {
	v := m.granted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldGrantedBy returns the old "granted_by" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldGrantedBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGrantedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGrantedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrantedBy: %w", err)
	}
	return oldValue.GrantedBy, nil
}

// AddGrantedBy adds u to the "granted_by" field.
func (m *PermissionMutation) AddGrantedBy(u int32) {
	if m.addgranted_by != nil {
		*m.addgranted_by += u
	} else {
		m.addgranted_by = &u
	}
}

// AddedGrantedBy returns the value that was added to the "granted_by" field in this mutation.
func (m *PermissionMutation) AddedGrantedBy() (r int32, exists bool) {
	v := m.addgranted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearGrantedBy clears the value of the "granted_by" field.
func (m *PermissionMutation) ClearGrantedBy() {
	m.granted_by = nil
	m.addgranted_by = nil
	m.clearedFields[permission.FieldGrantedBy] = struct{}{}
}

// GrantedByCleared returns if the "granted_by" field was cleared in this mutation.
func (m *PermissionMutation) GrantedByCleared() bool {
	_, ok := m.clearedFields[permission.FieldGrantedBy]
	return ok
}

// ResetGrantedBy resets all changes to the "granted_by" field.
func (m *PermissionMutation) ResetGrantedBy() {
	m.granted_by = nil
	m.addgranted_by = nil
	delete(m.clearedFields, permission.FieldGrantedBy)
}

// SetExpiresAt sets the "expires_at" field.
func (m *PermissionMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *PermissionMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *PermissionMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[permission.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *PermissionMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[permission.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *PermissionMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, permission.FieldExpiresAt)
}

// SetFolderID sets the "folder" edge to the Folder entity by id.
func (m *PermissionMutation) SetFolderID(id string) {
	m.folder = &id
}

// ClearFolder clears the "folder" edge to the Folder entity.
func (m *PermissionMutation) ClearFolder() {
	m.clearedfolder = true
}

// FolderCleared reports if the "folder" edge to the Folder entity was cleared.
func (m *PermissionMutation) FolderCleared() bool {
	return m.clearedfolder
}

// FolderID returns the "folder" edge ID in the mutation.
func (m *PermissionMutation) FolderID() (id string, exists bool) {
	if m.folder != nil {
		return *m.folder, true
	}
	return
}

// FolderIDs returns the "folder" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FolderID instead. It exists only for internal usage by the builders.
func (m *PermissionMutation) FolderIDs() (ids []string) {
	if id := m.folder; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFolder resets all changes to the "folder" edge.
func (m *PermissionMutation) ResetFolder() {
	m.folder = nil
	m.clearedfolder = false
}

// SetSecretID sets the "secret" edge to the Secret entity by id.
func (m *PermissionMutation) SetSecretID(id string) {
	m.secret = &id
}

// ClearSecret clears the "secret" edge to the Secret entity.
func (m *PermissionMutation) ClearSecret() {
	m.clearedsecret = true
}

// SecretCleared reports if the "secret" edge to the Secret entity was cleared.
func (m *PermissionMutation) SecretCleared() bool {
	return m.clearedsecret
}

// SecretID returns the "secret" edge ID in the mutation.
func (m *PermissionMutation) SecretID() (id string, exists bool) {
	if m.secret != nil {
		return *m.secret, true
	}
	return
}

// SecretIDs returns the "secret" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SecretID instead. It exists only for internal usage by the builders.
func (m *PermissionMutation) SecretIDs() (ids []string) {
	if id := m.secret; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSecret resets all changes to the "secret" edge.
func (m *PermissionMutation) ResetSecret() {
	m.secret = nil
	m.clearedsecret = false
}

// Where appends a list predicates to the PermissionMutation builder.
func (m *PermissionMutation) Where(ps ...predicate.Permission) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PermissionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PermissionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Permission, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PermissionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PermissionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Permission).
func (m *PermissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PermissionMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.create_time != nil {
		fields = append(fields, permission.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, permission.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, permission.FieldDeleteTime)
	}
	if m.tenant_id != nil {
		fields = append(fields, permission.FieldTenantID)
	}
	if m.resource_type != nil {
		fields = append(fields, permission.FieldResourceType)
	}
	if m.resource_id != nil {
		fields = append(fields, permission.FieldResourceID)
	}
	if m.relation != nil {
		fields = append(fields, permission.FieldRelation)
	}
	if m.subject_type != nil {
		fields = append(fields, permission.FieldSubjectType)
	}
	if m.subject_id != nil {
		fields = append(fields, permission.FieldSubjectID)
	}
	if m.granted_by != nil {
		fields = append(fields, permission.FieldGrantedBy)
	}
	if m.expires_at != nil {
		fields = append(fields, permission.FieldExpiresAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PermissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case permission.FieldCreateTime:
		return m.CreateTime()
	case permission.FieldUpdateTime:
		return m.UpdateTime()
	case permission.FieldDeleteTime:
		return m.DeleteTime()
	case permission.FieldTenantID:
		return m.TenantID()
	case permission.FieldResourceType:
		return m.ResourceType()
	case permission.FieldResourceID:
		return m.ResourceID()
	case permission.FieldRelation:
		return m.Relation()
	case permission.FieldSubjectType:
		return m.SubjectType()
	case permission.FieldSubjectID:
		return m.SubjectID()
	case permission.FieldGrantedBy:
		return m.GrantedBy()
	case permission.FieldExpiresAt:
		return m.ExpiresAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PermissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case permission.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case permission.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case permission.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case permission.FieldTenantID:
		return m.OldTenantID(ctx)
	case permission.FieldResourceType:
		return m.OldResourceType(ctx)
	case permission.FieldResourceID:
		return m.OldResourceID(ctx)
	case permission.FieldRelation:
		return m.OldRelation(ctx)
	case permission.FieldSubjectType:
		return m.OldSubjectType(ctx)
	case permission.FieldSubjectID:
		return m.OldSubjectID(ctx)
	case permission.FieldGrantedBy:
		return m.OldGrantedBy(ctx)
	case permission.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	}
	return nil, fmt.Errorf("unknown Permission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case permission.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case permission.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case permission.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case permission.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case permission.FieldResourceType:
		v, ok := value.(permission.ResourceType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceType(v)
		return nil
	case permission.FieldResourceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceID(v)
		return nil
	case permission.FieldRelation:
		v, ok := value.(permission.Relation)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelation(v)
		return nil
	case permission.FieldSubjectType:
		v, ok := value.(permission.SubjectType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectType(v)
		return nil
	case permission.FieldSubjectID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectID(v)
		return nil
	case permission.FieldGrantedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrantedBy(v)
		return nil
	case permission.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	}
	return fmt.Errorf("unknown Permission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PermissionMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, permission.FieldTenantID)
	}
	if m.addgranted_by != nil {
		fields = append(fields, permission.FieldGrantedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PermissionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case permission.FieldTenantID:
		return m.AddedTenantID()
	case permission.FieldGrantedBy:
		return m.AddedGrantedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case permission.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case permission.FieldGrantedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGrantedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Permission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PermissionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(permission.FieldCreateTime) {
		fields = append(fields, permission.FieldCreateTime)
	}
	if m.FieldCleared(permission.FieldUpdateTime) {
		fields = append(fields, permission.FieldUpdateTime)
	}
	if m.FieldCleared(permission.FieldDeleteTime) {
		fields = append(fields, permission.FieldDeleteTime)
	}
	if m.FieldCleared(permission.FieldTenantID) {
		fields = append(fields, permission.FieldTenantID)
	}
	if m.FieldCleared(permission.FieldGrantedBy) {
		fields = append(fields, permission.FieldGrantedBy)
	}
	if m.FieldCleared(permission.FieldExpiresAt) {
		fields = append(fields, permission.FieldExpiresAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PermissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PermissionMutation) ClearField(name string) error {
	switch name {
	case permission.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case permission.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	case permission.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case permission.FieldTenantID:
		m.ClearTenantID()
		return nil
	case permission.FieldGrantedBy:
		m.ClearGrantedBy()
		return nil
	case permission.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown Permission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PermissionMutation) ResetField(name string) error {
	switch name {
	case permission.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case permission.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case permission.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case permission.FieldTenantID:
		m.ResetTenantID()
		return nil
	case permission.FieldResourceType:
		m.ResetResourceType()
		return nil
	case permission.FieldResourceID:
		m.ResetResourceID()
		return nil
	case permission.FieldRelation:
		m.ResetRelation()
		return nil
	case permission.FieldSubjectType:
		m.ResetSubjectType()
		return nil
	case permission.FieldSubjectID:
		m.ResetSubjectID()
		return nil
	case permission.FieldGrantedBy:
		m.ResetGrantedBy()
		return nil
	case permission.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown Permission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PermissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.folder != nil {
		edges = append(edges, permission.EdgeFolder)
	}
	if m.secret != nil {
		edges = append(edges, permission.EdgeSecret)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PermissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case permission.EdgeFolder:
		if id := m.folder; id != nil {
			return []ent.Value{*id}
		}
	case permission.EdgeSecret:
		if id := m.secret; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PermissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PermissionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PermissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedfolder {
		edges = append(edges, permission.EdgeFolder)
	}
	if m.clearedsecret {
		edges = append(edges, permission.EdgeSecret)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PermissionMutation) EdgeCleared(name string) bool {
	switch name {
	case permission.EdgeFolder:
		return m.clearedfolder
	case permission.EdgeSecret:
		return m.clearedsecret
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PermissionMutation) ClearEdge(name string) error {
	switch name {
	case permission.EdgeFolder:
		m.ClearFolder()
		return nil
	case permission.EdgeSecret:
		m.ClearSecret()
		return nil
	}
	return fmt.Errorf("unknown Permission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PermissionMutation) ResetEdge(name string) error {
	switch name {
	case permission.EdgeFolder:
		m.ResetFolder()
		return nil
	case permission.EdgeSecret:
		m.ResetSecret()
		return nil
	}
	return fmt.Errorf("unknown Permission edge %s", name)
}

// SecretMutation represents an operation that mutates the Secret nodes in the graph.
type SecretMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	create_by          *uint32
	addcreate_by       *int32
	update_by          *uint32
	addupdate_by       *int32
	create_time        *time.Time
	update_time        *time.Time
	delete_time        *time.Time
	tenant_id          *uint32
	addtenant_id       *int32
	name               *string
	username           *string
	host_url           *string
	vault_path         *string
	current_version    *int32
	addcurrent_version *int32
	metadata           *map[string]interface{}
	description        *string
	status             *secret.Status
	clearedFields      map[string]struct{}
	folder             *string
	clearedfolder      bool
	versions           map[int]struct{}
	removedversions    map[int]struct{}
	clearedversions    bool
	permissions        map[int]struct{}
	removedpermissions map[int]struct{}
	clearedpermissions bool
	done               bool
	oldValue           func(context.Context) (*Secret, error)
	predicates         []predicate.Secret
}

var _ ent.Mutation = (*SecretMutation)(nil)

// secretOption allows management of the mutation configuration using functional options.
type secretOption func(*SecretMutation)

// newSecretMutation creates new mutation for the Secret entity.
func newSecretMutation(c config, op Op, opts ...secretOption) *SecretMutation {
	m := &SecretMutation{
		config:        c,
		op:            op,
		typ:           TypeSecret,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSecretID sets the ID field of the mutation.
func withSecretID(id string) secretOption {
	return func(m *SecretMutation) {
		var (
			err   error
			once  sync.Once
			value *Secret
		)
		m.oldValue = func(ctx context.Context) (*Secret, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Secret.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSecret sets the old Secret of the mutation.
func withSecret(node *Secret) secretOption {
	return func(m *SecretMutation) {
		m.oldValue = func(context.Context) (*Secret, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SecretMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SecretMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Secret entities.
func (m *SecretMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SecretMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SecretMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Secret.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateBy sets the "create_by" field.
func (m *SecretMutation) SetCreateBy(u uint32) {
	m.create_by = &u
	m.addcreate_by = nil
}

// CreateBy returns the value of the "create_by" field in the mutation.
func (m *SecretMutation) CreateBy() (r uint32, exists bool) {
	v := m.create_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "create_by" field's value of the Secret entity.
// If the Secret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecretMutation) OldCreateBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds u to the "create_by" field.
func (m *SecretMutation) AddCreateBy(u int32) {
	if m.addcreate_by != nil {
		*m.addcreate_by += u
	} else {
		m.addcreate_by = &u
	}
}

// AddedCreateBy returns the value that was added to the "create_by" field in this mutation.
func (m *SecretMutation) AddedCreateBy() (r int32, exists bool) {
	v := m.addcreate_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateBy clears the value of the "create_by" field.
func (m *SecretMutation) ClearCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	m.clearedFields[secret.FieldCreateBy] = struct{}{}
}

// CreateByCleared returns if the "create_by" field was cleared in this mutation.
func (m *SecretMutation) CreateByCleared() bool {
	_, ok := m.clearedFields[secret.FieldCreateBy]
	return ok
}

// ResetCreateBy resets all changes to the "create_by" field.
func (m *SecretMutation) ResetCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	delete(m.clearedFields, secret.FieldCreateBy)
}

// SetUpdateBy sets the "update_by" field.
func (m *SecretMutation) SetUpdateBy(u uint32) {
	m.update_by = &u
	m.addupdate_by = nil
}

// UpdateBy returns the value of the "update_by" field in the mutation.
func (m *SecretMutation) UpdateBy() (r uint32, exists bool) {
	v := m.update_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "update_by" field's value of the Secret entity.
// If the Secret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecretMutation) OldUpdateBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds u to the "update_by" field.
func (m *SecretMutation) AddUpdateBy(u int32) {
	if m.addupdate_by != nil {
		*m.addupdate_by += u
	} else {
		m.addupdate_by = &u
	}
}

// AddedUpdateBy returns the value that was added to the "update_by" field in this mutation.
func (m *SecretMutation) AddedUpdateBy() (r int32, exists bool) {
	v := m.addupdate_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateBy clears the value of the "update_by" field.
func (m *SecretMutation) ClearUpdateBy() {
	m.update_by = nil
	m.addupdate_by = nil
	m.clearedFields[secret.FieldUpdateBy] = struct{}{}
}

// UpdateByCleared returns if the "update_by" field was cleared in this mutation.
func (m *SecretMutation) UpdateByCleared() bool {
	_, ok := m.clearedFields[secret.FieldUpdateBy]
	return ok
}

// ResetUpdateBy resets all changes to the "update_by" field.
func (m *SecretMutation) ResetUpdateBy() {
	m.update_by = nil
	m.addupdate_by = nil
	delete(m.clearedFields, secret.FieldUpdateBy)
}

// SetCreateTime sets the "create_time" field.
func (m *SecretMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SecretMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Secret entity.
// If the Secret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecretMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *SecretMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[secret.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *SecretMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[secret.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SecretMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, secret.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *SecretMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SecretMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Secret entity.
// If the Secret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecretMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *SecretMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[secret.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *SecretMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[secret.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SecretMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, secret.FieldUpdateTime)
}

// SetDeleteTime sets the "delete_time" field.
func (m *SecretMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *SecretMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the Secret entity.
// If the Secret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecretMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *SecretMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[secret.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *SecretMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[secret.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *SecretMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, secret.FieldDeleteTime)
}

// SetTenantID sets the "tenant_id" field.
func (m *SecretMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *SecretMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Secret entity.
// If the Secret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecretMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *SecretMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *SecretMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *SecretMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[secret.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *SecretMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[secret.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *SecretMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, secret.FieldTenantID)
}

// SetFolderID sets the "folder_id" field.
func (m *SecretMutation) SetFolderID(s string) {
	m.folder = &s
}

// FolderID returns the value of the "folder_id" field in the mutation.
func (m *SecretMutation) FolderID() (r string, exists bool) {
	v := m.folder
	if v == nil {
		return
	}
	return *v, true
}

// OldFolderID returns the old "folder_id" field's value of the Secret entity.
// If the Secret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecretMutation) OldFolderID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFolderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFolderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFolderID: %w", err)
	}
	return oldValue.FolderID, nil
}

// ClearFolderID clears the value of the "folder_id" field.
func (m *SecretMutation) ClearFolderID() {
	m.folder = nil
	m.clearedFields[secret.FieldFolderID] = struct{}{}
}

// FolderIDCleared returns if the "folder_id" field was cleared in this mutation.
func (m *SecretMutation) FolderIDCleared() bool {
	_, ok := m.clearedFields[secret.FieldFolderID]
	return ok
}

// ResetFolderID resets all changes to the "folder_id" field.
func (m *SecretMutation) ResetFolderID() {
	m.folder = nil
	delete(m.clearedFields, secret.FieldFolderID)
}

// SetName sets the "name" field.
func (m *SecretMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SecretMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Secret entity.
// If the Secret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecretMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SecretMutation) ResetName() {
	m.name = nil
}

// SetUsername sets the "username" field.
func (m *SecretMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *SecretMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Secret entity.
// If the Secret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecretMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ClearUsername clears the value of the "username" field.
func (m *SecretMutation) ClearUsername() {
	m.username = nil
	m.clearedFields[secret.FieldUsername] = struct{}{}
}

// UsernameCleared returns if the "username" field was cleared in this mutation.
func (m *SecretMutation) UsernameCleared() bool {
	_, ok := m.clearedFields[secret.FieldUsername]
	return ok
}

// ResetUsername resets all changes to the "username" field.
func (m *SecretMutation) ResetUsername() {
	m.username = nil
	delete(m.clearedFields, secret.FieldUsername)
}

// SetHostURL sets the "host_url" field.
func (m *SecretMutation) SetHostURL(s string) {
	m.host_url = &s
}

// HostURL returns the value of the "host_url" field in the mutation.
func (m *SecretMutation) HostURL() (r string, exists bool) {
	v := m.host_url
	if v == nil {
		return
	}
	return *v, true
}

// OldHostURL returns the old "host_url" field's value of the Secret entity.
// If the Secret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecretMutation) OldHostURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHostURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHostURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostURL: %w", err)
	}
	return oldValue.HostURL, nil
}

// ClearHostURL clears the value of the "host_url" field.
func (m *SecretMutation) ClearHostURL() {
	m.host_url = nil
	m.clearedFields[secret.FieldHostURL] = struct{}{}
}

// HostURLCleared returns if the "host_url" field was cleared in this mutation.
func (m *SecretMutation) HostURLCleared() bool {
	_, ok := m.clearedFields[secret.FieldHostURL]
	return ok
}

// ResetHostURL resets all changes to the "host_url" field.
func (m *SecretMutation) ResetHostURL() {
	m.host_url = nil
	delete(m.clearedFields, secret.FieldHostURL)
}

// SetVaultPath sets the "vault_path" field.
func (m *SecretMutation) SetVaultPath(s string) {
	m.vault_path = &s
}

// VaultPath returns the value of the "vault_path" field in the mutation.
func (m *SecretMutation) VaultPath() (r string, exists bool) {
	v := m.vault_path
	if v == nil {
		return
	}
	return *v, true
}

// OldVaultPath returns the old "vault_path" field's value of the Secret entity.
// If the Secret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecretMutation) OldVaultPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVaultPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVaultPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVaultPath: %w", err)
	}
	return oldValue.VaultPath, nil
}

// ResetVaultPath resets all changes to the "vault_path" field.
func (m *SecretMutation) ResetVaultPath() {
	m.vault_path = nil
}

// SetCurrentVersion sets the "current_version" field.
func (m *SecretMutation) SetCurrentVersion(i int32) {
	m.current_version = &i
	m.addcurrent_version = nil
}

// CurrentVersion returns the value of the "current_version" field in the mutation.
func (m *SecretMutation) CurrentVersion() (r int32, exists bool) {
	v := m.current_version
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentVersion returns the old "current_version" field's value of the Secret entity.
// If the Secret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecretMutation) OldCurrentVersion(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentVersion: %w", err)
	}
	return oldValue.CurrentVersion, nil
}

// AddCurrentVersion adds i to the "current_version" field.
func (m *SecretMutation) AddCurrentVersion(i int32) {
	if m.addcurrent_version != nil {
		*m.addcurrent_version += i
	} else {
		m.addcurrent_version = &i
	}
}

// AddedCurrentVersion returns the value that was added to the "current_version" field in this mutation.
func (m *SecretMutation) AddedCurrentVersion() (r int32, exists bool) {
	v := m.addcurrent_version
	if v == nil {
		return
	}
	return *v, true
}

// ResetCurrentVersion resets all changes to the "current_version" field.
func (m *SecretMutation) ResetCurrentVersion() {
	m.current_version = nil
	m.addcurrent_version = nil
}

// SetMetadata sets the "metadata" field.
func (m *SecretMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *SecretMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Secret entity.
// If the Secret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecretMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *SecretMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[secret.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *SecretMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[secret.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *SecretMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, secret.FieldMetadata)
}

// SetDescription sets the "description" field.
func (m *SecretMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SecretMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Secret entity.
// If the Secret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecretMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SecretMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[secret.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SecretMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[secret.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SecretMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, secret.FieldDescription)
}

// SetStatus sets the "status" field.
func (m *SecretMutation) SetStatus(s secret.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *SecretMutation) Status() (r secret.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Secret entity.
// If the Secret object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecretMutation) OldStatus(ctx context.Context) (v secret.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *SecretMutation) ResetStatus() {
	m.status = nil
}

// ClearFolder clears the "folder" edge to the Folder entity.
func (m *SecretMutation) ClearFolder() {
	m.clearedfolder = true
	m.clearedFields[secret.FieldFolderID] = struct{}{}
}

// FolderCleared reports if the "folder" edge to the Folder entity was cleared.
func (m *SecretMutation) FolderCleared() bool {
	return m.FolderIDCleared() || m.clearedfolder
}

// FolderIDs returns the "folder" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FolderID instead. It exists only for internal usage by the builders.
func (m *SecretMutation) FolderIDs() (ids []string) {
	if id := m.folder; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFolder resets all changes to the "folder" edge.
func (m *SecretMutation) ResetFolder() {
	m.folder = nil
	m.clearedfolder = false
}

// AddVersionIDs adds the "versions" edge to the SecretVersion entity by ids.
func (m *SecretMutation) AddVersionIDs(ids ...int) {
	if m.versions == nil {
		m.versions = make(map[int]struct{})
	}
	for i := range ids {
		m.versions[ids[i]] = struct{}{}
	}
}

// ClearVersions clears the "versions" edge to the SecretVersion entity.
func (m *SecretMutation) ClearVersions() {
	m.clearedversions = true
}

// VersionsCleared reports if the "versions" edge to the SecretVersion entity was cleared.
func (m *SecretMutation) VersionsCleared() bool {
	return m.clearedversions
}

// RemoveVersionIDs removes the "versions" edge to the SecretVersion entity by IDs.
func (m *SecretMutation) RemoveVersionIDs(ids ...int) {
	if m.removedversions == nil {
		m.removedversions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.versions, ids[i])
		m.removedversions[ids[i]] = struct{}{}
	}
}

// RemovedVersions returns the removed IDs of the "versions" edge to the SecretVersion entity.
func (m *SecretMutation) RemovedVersionsIDs() (ids []int) {
	for id := range m.removedversions {
		ids = append(ids, id)
	}
	return
}

// VersionsIDs returns the "versions" edge IDs in the mutation.
func (m *SecretMutation) VersionsIDs() (ids []int) {
	for id := range m.versions {
		ids = append(ids, id)
	}
	return
}

// ResetVersions resets all changes to the "versions" edge.
func (m *SecretMutation) ResetVersions() {
	m.versions = nil
	m.clearedversions = false
	m.removedversions = nil
}

// AddPermissionIDs adds the "permissions" edge to the Permission entity by ids.
func (m *SecretMutation) AddPermissionIDs(ids ...int) {
	if m.permissions == nil {
		m.permissions = make(map[int]struct{})
	}
	for i := range ids {
		m.permissions[ids[i]] = struct{}{}
	}
}

// ClearPermissions clears the "permissions" edge to the Permission entity.
func (m *SecretMutation) ClearPermissions() {
	m.clearedpermissions = true
}

// PermissionsCleared reports if the "permissions" edge to the Permission entity was cleared.
func (m *SecretMutation) PermissionsCleared() bool {
	return m.clearedpermissions
}

// RemovePermissionIDs removes the "permissions" edge to the Permission entity by IDs.
func (m *SecretMutation) RemovePermissionIDs(ids ...int) {
	if m.removedpermissions == nil {
		m.removedpermissions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.permissions, ids[i])
		m.removedpermissions[ids[i]] = struct{}{}
	}
}

// RemovedPermissions returns the removed IDs of the "permissions" edge to the Permission entity.
func (m *SecretMutation) RemovedPermissionsIDs() (ids []int) {
	for id := range m.removedpermissions {
		ids = append(ids, id)
	}
	return
}

// PermissionsIDs returns the "permissions" edge IDs in the mutation.
func (m *SecretMutation) PermissionsIDs() (ids []int) {
	for id := range m.permissions {
		ids = append(ids, id)
	}
	return
}

// ResetPermissions resets all changes to the "permissions" edge.
func (m *SecretMutation) ResetPermissions() {
	m.permissions = nil
	m.clearedpermissions = false
	m.removedpermissions = nil
}

// Where appends a list predicates to the SecretMutation builder.
func (m *SecretMutation) Where(ps ...predicate.Secret) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SecretMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SecretMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Secret, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SecretMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SecretMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Secret).
func (m *SecretMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SecretMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.create_by != nil {
		fields = append(fields, secret.FieldCreateBy)
	}
	if m.update_by != nil {
		fields = append(fields, secret.FieldUpdateBy)
	}
	if m.create_time != nil {
		fields = append(fields, secret.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, secret.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, secret.FieldDeleteTime)
	}
	if m.tenant_id != nil {
		fields = append(fields, secret.FieldTenantID)
	}
	if m.folder != nil {
		fields = append(fields, secret.FieldFolderID)
	}
	if m.name != nil {
		fields = append(fields, secret.FieldName)
	}
	if m.username != nil {
		fields = append(fields, secret.FieldUsername)
	}
	if m.host_url != nil {
		fields = append(fields, secret.FieldHostURL)
	}
	if m.vault_path != nil {
		fields = append(fields, secret.FieldVaultPath)
	}
	if m.current_version != nil {
		fields = append(fields, secret.FieldCurrentVersion)
	}
	if m.metadata != nil {
		fields = append(fields, secret.FieldMetadata)
	}
	if m.description != nil {
		fields = append(fields, secret.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, secret.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SecretMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case secret.FieldCreateBy:
		return m.CreateBy()
	case secret.FieldUpdateBy:
		return m.UpdateBy()
	case secret.FieldCreateTime:
		return m.CreateTime()
	case secret.FieldUpdateTime:
		return m.UpdateTime()
	case secret.FieldDeleteTime:
		return m.DeleteTime()
	case secret.FieldTenantID:
		return m.TenantID()
	case secret.FieldFolderID:
		return m.FolderID()
	case secret.FieldName:
		return m.Name()
	case secret.FieldUsername:
		return m.Username()
	case secret.FieldHostURL:
		return m.HostURL()
	case secret.FieldVaultPath:
		return m.VaultPath()
	case secret.FieldCurrentVersion:
		return m.CurrentVersion()
	case secret.FieldMetadata:
		return m.Metadata()
	case secret.FieldDescription:
		return m.Description()
	case secret.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SecretMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case secret.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case secret.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case secret.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case secret.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case secret.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case secret.FieldTenantID:
		return m.OldTenantID(ctx)
	case secret.FieldFolderID:
		return m.OldFolderID(ctx)
	case secret.FieldName:
		return m.OldName(ctx)
	case secret.FieldUsername:
		return m.OldUsername(ctx)
	case secret.FieldHostURL:
		return m.OldHostURL(ctx)
	case secret.FieldVaultPath:
		return m.OldVaultPath(ctx)
	case secret.FieldCurrentVersion:
		return m.OldCurrentVersion(ctx)
	case secret.FieldMetadata:
		return m.OldMetadata(ctx)
	case secret.FieldDescription:
		return m.OldDescription(ctx)
	case secret.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Secret field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SecretMutation) SetField(name string, value ent.Value) error {
	switch name {
	case secret.FieldCreateBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case secret.FieldUpdateBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case secret.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case secret.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case secret.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case secret.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case secret.FieldFolderID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFolderID(v)
		return nil
	case secret.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case secret.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case secret.FieldHostURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostURL(v)
		return nil
	case secret.FieldVaultPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVaultPath(v)
		return nil
	case secret.FieldCurrentVersion:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentVersion(v)
		return nil
	case secret.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case secret.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case secret.FieldStatus:
		v, ok := value.(secret.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Secret field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SecretMutation) AddedFields() []string {
	var fields []string
	if m.addcreate_by != nil {
		fields = append(fields, secret.FieldCreateBy)
	}
	if m.addupdate_by != nil {
		fields = append(fields, secret.FieldUpdateBy)
	}
	if m.addtenant_id != nil {
		fields = append(fields, secret.FieldTenantID)
	}
	if m.addcurrent_version != nil {
		fields = append(fields, secret.FieldCurrentVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SecretMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case secret.FieldCreateBy:
		return m.AddedCreateBy()
	case secret.FieldUpdateBy:
		return m.AddedUpdateBy()
	case secret.FieldTenantID:
		return m.AddedTenantID()
	case secret.FieldCurrentVersion:
		return m.AddedCurrentVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SecretMutation) AddField(name string, value ent.Value) error {
	switch name {
	case secret.FieldCreateBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case secret.FieldUpdateBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case secret.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case secret.FieldCurrentVersion:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCurrentVersion(v)
		return nil
	}
	return fmt.Errorf("unknown Secret numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SecretMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(secret.FieldCreateBy) {
		fields = append(fields, secret.FieldCreateBy)
	}
	if m.FieldCleared(secret.FieldUpdateBy) {
		fields = append(fields, secret.FieldUpdateBy)
	}
	if m.FieldCleared(secret.FieldCreateTime) {
		fields = append(fields, secret.FieldCreateTime)
	}
	if m.FieldCleared(secret.FieldUpdateTime) {
		fields = append(fields, secret.FieldUpdateTime)
	}
	if m.FieldCleared(secret.FieldDeleteTime) {
		fields = append(fields, secret.FieldDeleteTime)
	}
	if m.FieldCleared(secret.FieldTenantID) {
		fields = append(fields, secret.FieldTenantID)
	}
	if m.FieldCleared(secret.FieldFolderID) {
		fields = append(fields, secret.FieldFolderID)
	}
	if m.FieldCleared(secret.FieldUsername) {
		fields = append(fields, secret.FieldUsername)
	}
	if m.FieldCleared(secret.FieldHostURL) {
		fields = append(fields, secret.FieldHostURL)
	}
	if m.FieldCleared(secret.FieldMetadata) {
		fields = append(fields, secret.FieldMetadata)
	}
	if m.FieldCleared(secret.FieldDescription) {
		fields = append(fields, secret.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SecretMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SecretMutation) ClearField(name string) error {
	switch name {
	case secret.FieldCreateBy:
		m.ClearCreateBy()
		return nil
	case secret.FieldUpdateBy:
		m.ClearUpdateBy()
		return nil
	case secret.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case secret.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	case secret.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case secret.FieldTenantID:
		m.ClearTenantID()
		return nil
	case secret.FieldFolderID:
		m.ClearFolderID()
		return nil
	case secret.FieldUsername:
		m.ClearUsername()
		return nil
	case secret.FieldHostURL:
		m.ClearHostURL()
		return nil
	case secret.FieldMetadata:
		m.ClearMetadata()
		return nil
	case secret.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Secret nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SecretMutation) ResetField(name string) error {
	switch name {
	case secret.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case secret.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case secret.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case secret.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case secret.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case secret.FieldTenantID:
		m.ResetTenantID()
		return nil
	case secret.FieldFolderID:
		m.ResetFolderID()
		return nil
	case secret.FieldName:
		m.ResetName()
		return nil
	case secret.FieldUsername:
		m.ResetUsername()
		return nil
	case secret.FieldHostURL:
		m.ResetHostURL()
		return nil
	case secret.FieldVaultPath:
		m.ResetVaultPath()
		return nil
	case secret.FieldCurrentVersion:
		m.ResetCurrentVersion()
		return nil
	case secret.FieldMetadata:
		m.ResetMetadata()
		return nil
	case secret.FieldDescription:
		m.ResetDescription()
		return nil
	case secret.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Secret field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SecretMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.folder != nil {
		edges = append(edges, secret.EdgeFolder)
	}
	if m.versions != nil {
		edges = append(edges, secret.EdgeVersions)
	}
	if m.permissions != nil {
		edges = append(edges, secret.EdgePermissions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SecretMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case secret.EdgeFolder:
		if id := m.folder; id != nil {
			return []ent.Value{*id}
		}
	case secret.EdgeVersions:
		ids := make([]ent.Value, 0, len(m.versions))
		for id := range m.versions {
			ids = append(ids, id)
		}
		return ids
	case secret.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.permissions))
		for id := range m.permissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SecretMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedversions != nil {
		edges = append(edges, secret.EdgeVersions)
	}
	if m.removedpermissions != nil {
		edges = append(edges, secret.EdgePermissions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SecretMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case secret.EdgeVersions:
		ids := make([]ent.Value, 0, len(m.removedversions))
		for id := range m.removedversions {
			ids = append(ids, id)
		}
		return ids
	case secret.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.removedpermissions))
		for id := range m.removedpermissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SecretMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedfolder {
		edges = append(edges, secret.EdgeFolder)
	}
	if m.clearedversions {
		edges = append(edges, secret.EdgeVersions)
	}
	if m.clearedpermissions {
		edges = append(edges, secret.EdgePermissions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SecretMutation) EdgeCleared(name string) bool {
	switch name {
	case secret.EdgeFolder:
		return m.clearedfolder
	case secret.EdgeVersions:
		return m.clearedversions
	case secret.EdgePermissions:
		return m.clearedpermissions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SecretMutation) ClearEdge(name string) error {
	switch name {
	case secret.EdgeFolder:
		m.ClearFolder()
		return nil
	}
	return fmt.Errorf("unknown Secret unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SecretMutation) ResetEdge(name string) error {
	switch name {
	case secret.EdgeFolder:
		m.ResetFolder()
		return nil
	case secret.EdgeVersions:
		m.ResetVersions()
		return nil
	case secret.EdgePermissions:
		m.ResetPermissions()
		return nil
	}
	return fmt.Errorf("unknown Secret edge %s", name)
}

// SecretVersionMutation represents an operation that mutates the SecretVersion nodes in the graph.
type SecretVersionMutation struct {
	config
	op                Op
	typ               string
	id                *int
	create_by         *uint32
	addcreate_by      *int32
	create_time       *time.Time
	update_time       *time.Time
	delete_time       *time.Time
	version_number    *int32
	addversion_number *int32
	vault_path        *string
	comment           *string
	checksum          *string
	clearedFields     map[string]struct{}
	secret            *string
	clearedsecret     bool
	done              bool
	oldValue          func(context.Context) (*SecretVersion, error)
	predicates        []predicate.SecretVersion
}

var _ ent.Mutation = (*SecretVersionMutation)(nil)

// secretversionOption allows management of the mutation configuration using functional options.
type secretversionOption func(*SecretVersionMutation)

// newSecretVersionMutation creates new mutation for the SecretVersion entity.
func newSecretVersionMutation(c config, op Op, opts ...secretversionOption) *SecretVersionMutation {
	m := &SecretVersionMutation{
		config:        c,
		op:            op,
		typ:           TypeSecretVersion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSecretVersionID sets the ID field of the mutation.
func withSecretVersionID(id int) secretversionOption {
	return func(m *SecretVersionMutation) {
		var (
			err   error
			once  sync.Once
			value *SecretVersion
		)
		m.oldValue = func(ctx context.Context) (*SecretVersion, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SecretVersion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSecretVersion sets the old SecretVersion of the mutation.
func withSecretVersion(node *SecretVersion) secretversionOption {
	return func(m *SecretVersionMutation) {
		m.oldValue = func(context.Context) (*SecretVersion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SecretVersionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SecretVersionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SecretVersionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SecretVersionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SecretVersion.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateBy sets the "create_by" field.
func (m *SecretVersionMutation) SetCreateBy(u uint32) {
	m.create_by = &u
	m.addcreate_by = nil
}

// CreateBy returns the value of the "create_by" field in the mutation.
func (m *SecretVersionMutation) CreateBy() (r uint32, exists bool) {
	v := m.create_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "create_by" field's value of the SecretVersion entity.
// If the SecretVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecretVersionMutation) OldCreateBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds u to the "create_by" field.
func (m *SecretVersionMutation) AddCreateBy(u int32) {
	if m.addcreate_by != nil {
		*m.addcreate_by += u
	} else {
		m.addcreate_by = &u
	}
}

// AddedCreateBy returns the value that was added to the "create_by" field in this mutation.
func (m *SecretVersionMutation) AddedCreateBy() (r int32, exists bool) {
	v := m.addcreate_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateBy clears the value of the "create_by" field.
func (m *SecretVersionMutation) ClearCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	m.clearedFields[secretversion.FieldCreateBy] = struct{}{}
}

// CreateByCleared returns if the "create_by" field was cleared in this mutation.
func (m *SecretVersionMutation) CreateByCleared() bool {
	_, ok := m.clearedFields[secretversion.FieldCreateBy]
	return ok
}

// ResetCreateBy resets all changes to the "create_by" field.
func (m *SecretVersionMutation) ResetCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	delete(m.clearedFields, secretversion.FieldCreateBy)
}

// SetCreateTime sets the "create_time" field.
func (m *SecretVersionMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SecretVersionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the SecretVersion entity.
// If the SecretVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecretVersionMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *SecretVersionMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[secretversion.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *SecretVersionMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[secretversion.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SecretVersionMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, secretversion.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *SecretVersionMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SecretVersionMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the SecretVersion entity.
// If the SecretVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecretVersionMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *SecretVersionMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[secretversion.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *SecretVersionMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[secretversion.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SecretVersionMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, secretversion.FieldUpdateTime)
}

// SetDeleteTime sets the "delete_time" field.
func (m *SecretVersionMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *SecretVersionMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the SecretVersion entity.
// If the SecretVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecretVersionMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *SecretVersionMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[secretversion.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *SecretVersionMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[secretversion.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *SecretVersionMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, secretversion.FieldDeleteTime)
}

// SetSecretID sets the "secret_id" field.
func (m *SecretVersionMutation) SetSecretID(s string) {
	m.secret = &s
}

// SecretID returns the value of the "secret_id" field in the mutation.
func (m *SecretVersionMutation) SecretID() (r string, exists bool) {
	v := m.secret
	if v == nil {
		return
	}
	return *v, true
}

// OldSecretID returns the old "secret_id" field's value of the SecretVersion entity.
// If the SecretVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecretVersionMutation) OldSecretID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecretID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecretID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecretID: %w", err)
	}
	return oldValue.SecretID, nil
}

// ResetSecretID resets all changes to the "secret_id" field.
func (m *SecretVersionMutation) ResetSecretID() {
	m.secret = nil
}

// SetVersionNumber sets the "version_number" field.
func (m *SecretVersionMutation) SetVersionNumber(i int32) {
	m.version_number = &i
	m.addversion_number = nil
}

// VersionNumber returns the value of the "version_number" field in the mutation.
func (m *SecretVersionMutation) VersionNumber() (r int32, exists bool) {
	v := m.version_number
	if v == nil {
		return
	}
	return *v, true
}

// OldVersionNumber returns the old "version_number" field's value of the SecretVersion entity.
// If the SecretVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecretVersionMutation) OldVersionNumber(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersionNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersionNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersionNumber: %w", err)
	}
	return oldValue.VersionNumber, nil
}

// AddVersionNumber adds i to the "version_number" field.
func (m *SecretVersionMutation) AddVersionNumber(i int32) {
	if m.addversion_number != nil {
		*m.addversion_number += i
	} else {
		m.addversion_number = &i
	}
}

// AddedVersionNumber returns the value that was added to the "version_number" field in this mutation.
func (m *SecretVersionMutation) AddedVersionNumber() (r int32, exists bool) {
	v := m.addversion_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersionNumber resets all changes to the "version_number" field.
func (m *SecretVersionMutation) ResetVersionNumber() {
	m.version_number = nil
	m.addversion_number = nil
}

// SetVaultPath sets the "vault_path" field.
func (m *SecretVersionMutation) SetVaultPath(s string) {
	m.vault_path = &s
}

// VaultPath returns the value of the "vault_path" field in the mutation.
func (m *SecretVersionMutation) VaultPath() (r string, exists bool) {
	v := m.vault_path
	if v == nil {
		return
	}
	return *v, true
}

// OldVaultPath returns the old "vault_path" field's value of the SecretVersion entity.
// If the SecretVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecretVersionMutation) OldVaultPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVaultPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVaultPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVaultPath: %w", err)
	}
	return oldValue.VaultPath, nil
}

// ResetVaultPath resets all changes to the "vault_path" field.
func (m *SecretVersionMutation) ResetVaultPath() {
	m.vault_path = nil
}

// SetComment sets the "comment" field.
func (m *SecretVersionMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *SecretVersionMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the SecretVersion entity.
// If the SecretVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecretVersionMutation) OldComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ClearComment clears the value of the "comment" field.
func (m *SecretVersionMutation) ClearComment() {
	m.comment = nil
	m.clearedFields[secretversion.FieldComment] = struct{}{}
}

// CommentCleared returns if the "comment" field was cleared in this mutation.
func (m *SecretVersionMutation) CommentCleared() bool {
	_, ok := m.clearedFields[secretversion.FieldComment]
	return ok
}

// ResetComment resets all changes to the "comment" field.
func (m *SecretVersionMutation) ResetComment() {
	m.comment = nil
	delete(m.clearedFields, secretversion.FieldComment)
}

// SetChecksum sets the "checksum" field.
func (m *SecretVersionMutation) SetChecksum(s string) {
	m.checksum = &s
}

// Checksum returns the value of the "checksum" field in the mutation.
func (m *SecretVersionMutation) Checksum() (r string, exists bool) {
	v := m.checksum
	if v == nil {
		return
	}
	return *v, true
}

// OldChecksum returns the old "checksum" field's value of the SecretVersion entity.
// If the SecretVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecretVersionMutation) OldChecksum(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChecksum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChecksum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChecksum: %w", err)
	}
	return oldValue.Checksum, nil
}

// ResetChecksum resets all changes to the "checksum" field.
func (m *SecretVersionMutation) ResetChecksum() {
	m.checksum = nil
}

// ClearSecret clears the "secret" edge to the Secret entity.
func (m *SecretVersionMutation) ClearSecret() {
	m.clearedsecret = true
	m.clearedFields[secretversion.FieldSecretID] = struct{}{}
}

// SecretCleared reports if the "secret" edge to the Secret entity was cleared.
func (m *SecretVersionMutation) SecretCleared() bool {
	return m.clearedsecret
}

// SecretIDs returns the "secret" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SecretID instead. It exists only for internal usage by the builders.
func (m *SecretVersionMutation) SecretIDs() (ids []string) {
	if id := m.secret; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSecret resets all changes to the "secret" edge.
func (m *SecretVersionMutation) ResetSecret() {
	m.secret = nil
	m.clearedsecret = false
}

// Where appends a list predicates to the SecretVersionMutation builder.
func (m *SecretVersionMutation) Where(ps ...predicate.SecretVersion) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SecretVersionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SecretVersionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SecretVersion, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SecretVersionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SecretVersionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SecretVersion).
func (m *SecretVersionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SecretVersionMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.create_by != nil {
		fields = append(fields, secretversion.FieldCreateBy)
	}
	if m.create_time != nil {
		fields = append(fields, secretversion.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, secretversion.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, secretversion.FieldDeleteTime)
	}
	if m.secret != nil {
		fields = append(fields, secretversion.FieldSecretID)
	}
	if m.version_number != nil {
		fields = append(fields, secretversion.FieldVersionNumber)
	}
	if m.vault_path != nil {
		fields = append(fields, secretversion.FieldVaultPath)
	}
	if m.comment != nil {
		fields = append(fields, secretversion.FieldComment)
	}
	if m.checksum != nil {
		fields = append(fields, secretversion.FieldChecksum)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SecretVersionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case secretversion.FieldCreateBy:
		return m.CreateBy()
	case secretversion.FieldCreateTime:
		return m.CreateTime()
	case secretversion.FieldUpdateTime:
		return m.UpdateTime()
	case secretversion.FieldDeleteTime:
		return m.DeleteTime()
	case secretversion.FieldSecretID:
		return m.SecretID()
	case secretversion.FieldVersionNumber:
		return m.VersionNumber()
	case secretversion.FieldVaultPath:
		return m.VaultPath()
	case secretversion.FieldComment:
		return m.Comment()
	case secretversion.FieldChecksum:
		return m.Checksum()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SecretVersionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case secretversion.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case secretversion.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case secretversion.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case secretversion.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case secretversion.FieldSecretID:
		return m.OldSecretID(ctx)
	case secretversion.FieldVersionNumber:
		return m.OldVersionNumber(ctx)
	case secretversion.FieldVaultPath:
		return m.OldVaultPath(ctx)
	case secretversion.FieldComment:
		return m.OldComment(ctx)
	case secretversion.FieldChecksum:
		return m.OldChecksum(ctx)
	}
	return nil, fmt.Errorf("unknown SecretVersion field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SecretVersionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case secretversion.FieldCreateBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case secretversion.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case secretversion.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case secretversion.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case secretversion.FieldSecretID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecretID(v)
		return nil
	case secretversion.FieldVersionNumber:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersionNumber(v)
		return nil
	case secretversion.FieldVaultPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVaultPath(v)
		return nil
	case secretversion.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	case secretversion.FieldChecksum:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChecksum(v)
		return nil
	}
	return fmt.Errorf("unknown SecretVersion field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SecretVersionMutation) AddedFields() []string {
	var fields []string
	if m.addcreate_by != nil {
		fields = append(fields, secretversion.FieldCreateBy)
	}
	if m.addversion_number != nil {
		fields = append(fields, secretversion.FieldVersionNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SecretVersionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case secretversion.FieldCreateBy:
		return m.AddedCreateBy()
	case secretversion.FieldVersionNumber:
		return m.AddedVersionNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SecretVersionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case secretversion.FieldCreateBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case secretversion.FieldVersionNumber:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersionNumber(v)
		return nil
	}
	return fmt.Errorf("unknown SecretVersion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SecretVersionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(secretversion.FieldCreateBy) {
		fields = append(fields, secretversion.FieldCreateBy)
	}
	if m.FieldCleared(secretversion.FieldCreateTime) {
		fields = append(fields, secretversion.FieldCreateTime)
	}
	if m.FieldCleared(secretversion.FieldUpdateTime) {
		fields = append(fields, secretversion.FieldUpdateTime)
	}
	if m.FieldCleared(secretversion.FieldDeleteTime) {
		fields = append(fields, secretversion.FieldDeleteTime)
	}
	if m.FieldCleared(secretversion.FieldComment) {
		fields = append(fields, secretversion.FieldComment)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SecretVersionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SecretVersionMutation) ClearField(name string) error {
	switch name {
	case secretversion.FieldCreateBy:
		m.ClearCreateBy()
		return nil
	case secretversion.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case secretversion.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	case secretversion.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case secretversion.FieldComment:
		m.ClearComment()
		return nil
	}
	return fmt.Errorf("unknown SecretVersion nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SecretVersionMutation) ResetField(name string) error {
	switch name {
	case secretversion.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case secretversion.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case secretversion.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case secretversion.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case secretversion.FieldSecretID:
		m.ResetSecretID()
		return nil
	case secretversion.FieldVersionNumber:
		m.ResetVersionNumber()
		return nil
	case secretversion.FieldVaultPath:
		m.ResetVaultPath()
		return nil
	case secretversion.FieldComment:
		m.ResetComment()
		return nil
	case secretversion.FieldChecksum:
		m.ResetChecksum()
		return nil
	}
	return fmt.Errorf("unknown SecretVersion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SecretVersionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.secret != nil {
		edges = append(edges, secretversion.EdgeSecret)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SecretVersionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case secretversion.EdgeSecret:
		if id := m.secret; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SecretVersionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SecretVersionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SecretVersionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsecret {
		edges = append(edges, secretversion.EdgeSecret)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SecretVersionMutation) EdgeCleared(name string) bool {
	switch name {
	case secretversion.EdgeSecret:
		return m.clearedsecret
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SecretVersionMutation) ClearEdge(name string) error {
	switch name {
	case secretversion.EdgeSecret:
		m.ClearSecret()
		return nil
	}
	return fmt.Errorf("unknown SecretVersion unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SecretVersionMutation) ResetEdge(name string) error {
	switch name {
	case secretversion.EdgeSecret:
		m.ResetSecret()
		return nil
	}
	return fmt.Errorf("unknown SecretVersion edge %s", name)
}
