syntax = "proto3";

package warden.service.v1;


import "buf/validate/validate.proto";
import "google/api/annotations.proto";
import "google/api/field_behavior.proto";
import "google/protobuf/empty.proto";
import "warden/service/v1/permission.proto";

// Bitwarden Transfer Service - handles import/export in Bitwarden JSON format
service WardenBitwardenTransferService {
  // Export all secrets and folders as Bitwarden-compatible JSON
  rpc ExportToBitwarden(ExportToBitwardenRequest) returns (ExportToBitwardenResponse) {
    option (google.api.http) = {
      post: "/v1/bitwarden/export"
      body: "*"
    };
  }

  // Import secrets and folders from Bitwarden JSON
  rpc ImportFromBitwarden(ImportFromBitwardenRequest) returns (ImportFromBitwardenResponse) {
    option (google.api.http) = {
      post: "/v1/bitwarden/import"
      body: "*"
    };
  }

  // Validate Bitwarden JSON without importing (dry-run)
  rpc ValidateBitwardenImport(ValidateBitwardenImportRequest) returns (ValidateBitwardenImportResponse) {
    option (google.api.http) = {
      post: "/v1/bitwarden/validate"
      body: "*"
    };
  }
}

// Bitwarden item types
enum BitwardenItemType {
  BITWARDEN_ITEM_TYPE_UNSPECIFIED = 0;
  BITWARDEN_ITEM_TYPE_LOGIN = 1;
  BITWARDEN_ITEM_TYPE_SECURE_NOTE = 2;
  BITWARDEN_ITEM_TYPE_CARD = 3;
  BITWARDEN_ITEM_TYPE_IDENTITY = 4;
}

// Bitwarden folder structure
message BitwardenFolder {
  string id = 1 [json_name = "id"];
  string name = 2 [json_name = "name"];
}

// Bitwarden login URI
message BitwardenUri {
  string uri = 1 [json_name = "uri"];
  optional int32 match = 2 [json_name = "match"];
}

// Bitwarden login data
message BitwardenLogin {
  repeated BitwardenUri uris = 1 [json_name = "uris"];
  string username = 2 [json_name = "username"];
  string password = 3 [json_name = "password"];
  optional string totp = 4 [json_name = "totp"];
}

// Bitwarden custom field
message BitwardenField {
  string name = 1 [json_name = "name"];
  string value = 2 [json_name = "value"];
  int32 type = 3 [json_name = "type"]; // 0=Text, 1=Hidden, 2=Boolean, 3=Linked
}

// Bitwarden password history entry
message BitwardenPasswordHistory {
  string last_used_date = 1 [json_name = "lastUsedDate"];
  string password = 2 [json_name = "password"];
}

// Bitwarden item (secret)
message BitwardenItem {
  string id = 1 [json_name = "id"];
  optional string folder_id = 2 [json_name = "folderId"];
  int32 type = 3 [json_name = "type"];
  string name = 4 [json_name = "name"];
  optional string notes = 5 [json_name = "notes"];
  bool favorite = 6 [json_name = "favorite"];
  optional BitwardenLogin login = 7 [json_name = "login"];
  repeated BitwardenField fields = 8 [json_name = "fields"];
  repeated BitwardenPasswordHistory password_history = 9 [json_name = "passwordHistory"];
  optional string creation_date = 10 [json_name = "creationDate"];
  optional string revision_date = 11 [json_name = "revisionDate"];
}

// Full Bitwarden export structure
message BitwardenExport {
  bool encrypted = 1 [json_name = "encrypted"];
  repeated BitwardenFolder folders = 2 [json_name = "folders"];
  repeated BitwardenItem items = 3 [json_name = "items"];
}

// How to handle duplicate names during import
enum DuplicateHandling {
  DUPLICATE_HANDLING_UNSPECIFIED = 0;
  DUPLICATE_HANDLING_SKIP = 1;      // Skip items with duplicate names
  DUPLICATE_HANDLING_RENAME = 2;    // Rename with suffix (e.g., "name (1)")
  DUPLICATE_HANDLING_OVERWRITE = 3; // Replace existing
}

// Export request
message ExportToBitwardenRequest {
  // Optional: only export secrets from specific folder and subfolders
  optional string folder_id = 1 [
    json_name = "folderId",
    (buf.validate.field).string = {
      max_len: 36
      pattern: "^[a-fA-F0-9\\-]*$"
    }
  ];

  // Include secrets from subfolders (default: true)
  bool include_subfolders = 2 [json_name = "includeSubfolders"];
}

message ExportToBitwardenResponse {
  // JSON string in Bitwarden format
  string json_data = 1 [json_name = "jsonData"];

  // Statistics
  int32 folders_exported = 2 [json_name = "foldersExported"];
  int32 items_exported = 3 [json_name = "itemsExported"];
  int32 items_skipped = 4 [json_name = "itemsSkipped"];

  // Filename suggestion
  string suggested_filename = 5 [json_name = "suggestedFilename"];
}

// Permission rule to apply to all imported items
message ImportPermissionRule {
  SubjectType subject_type = 1 [json_name = "subjectType"];
  string subject_id = 2 [json_name = "subjectId"];
  Relation relation = 3 [json_name = "relation"];
}

// Import request
message ImportFromBitwardenRequest {
  // JSON data (Bitwarden export format)
  string json_data = 1 [
    json_name = "jsonData",
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string = {min_len: 2, max_len: 10485760}  // Max 10MB
  ];

  // Target folder to import into (null for root)
  optional string target_folder_id = 2 [
    json_name = "targetFolderId",
    (buf.validate.field).string = {
      max_len: 36
      pattern: "^[a-fA-F0-9\\-]*$"
    }
  ];

  // How to handle duplicate names
  DuplicateHandling duplicate_handling = 3 [json_name = "duplicateHandling"];

  // Whether to import folder structure or flatten to target folder
  bool preserve_folders = 4 [json_name = "preserveFolders"];

  // Permission rules to apply to all imported folders and secrets
  repeated ImportPermissionRule permission_rules = 5 [json_name = "permissionRules"];
}

message ImportFromBitwardenResponse {
  // Import statistics
  int32 folders_created = 1 [json_name = "foldersCreated"];
  int32 items_imported = 2 [json_name = "itemsImported"];
  int32 items_skipped = 3 [json_name = "itemsSkipped"];
  int32 items_failed = 4 [json_name = "itemsFailed"];

  // Details of skipped/failed items
  repeated ImportError errors = 5 [json_name = "errors"];

  // Mapping of Bitwarden IDs to Warden IDs
  map<string, string> folder_id_mapping = 6 [json_name = "folderIdMapping"];
  map<string, string> item_id_mapping = 7 [json_name = "itemIdMapping"];
}

message ImportError {
  string bitwarden_id = 1 [json_name = "bitwardenId"];
  string item_name = 2 [json_name = "itemName"];
  string error_type = 3 [json_name = "errorType"]; // "duplicate", "validation", "unsupported_type"
  string message = 4 [json_name = "message"];
}

// Validation request (dry-run)
message ValidateBitwardenImportRequest {
  string json_data = 1 [
    json_name = "jsonData",
    (google.api.field_behavior) = REQUIRED,
    (buf.validate.field).string = {min_len: 2, max_len: 10485760}
  ];

  optional string target_folder_id = 2 [
    json_name = "targetFolderId",
    (buf.validate.field).string = {
      max_len: 36
      pattern: "^[a-fA-F0-9\\-]*$"
    }
  ];

  bool preserve_folders = 3 [json_name = "preserveFolders"];
}

message ValidateBitwardenImportResponse {
  bool is_valid = 1 [json_name = "isValid"];

  // Parse statistics
  int32 folders_found = 2 [json_name = "foldersFound"];
  int32 login_items_found = 3 [json_name = "loginItemsFound"];
  int32 other_items_found = 4 [json_name = "otherItemsFound"];

  // Potential issues
  repeated string warnings = 5 [json_name = "warnings"];
  repeated string errors = 6 [json_name = "errors"];

  // Duplicate detection
  repeated string duplicate_names = 7 [json_name = "duplicateNames"];
}
